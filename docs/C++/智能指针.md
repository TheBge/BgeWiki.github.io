#### 智能指针作用

提出智能指针时候，不得不提一下栈和堆。我们都知道，栈上的资源是由系统管理的，申请和释放资源都是由栈的策略来进行的。

而堆上的资源申请，是用户显示的调用关键字new 和 delete来进行申请资源和释放资源，该资源的生命周期是执行new语句申请资源    到执行 delete释放资源。（或者程序结束由系统释放这部分堆资源）。

这时候我们在来谈一下智能指针的作用和原理。

智能指针就是行为类似指针的栈对象，并非指针类型，在栈对象生命周期即将结束时，智能指针通过析构函数释放有它管理的堆内存。这样就能够不用手动释放内存了。  



shared_ptr: 
跟踪引用特定对象的智能指针数（引用计数）。仅当最后一个指针过期时，才调用delete。 
unique_ptr: 
建立所有权概念，对于特定的对象，只有一个智能指针可以拥有它，只有拥有对象的智能指针才可以释放它。并且，赋值操作将转让所有权，转让所有权后指针不再指向有效数据。这个过程将会非常严格。  



### C++中的smart pointer： shared_ptr, unique_ptr, weak_ptr, auto_ptr

C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。

#### 为什么要使用智能指针：

智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。



#### **auto_ptr（c++98的方案，cpp11已经抛弃）**

采用所有权模式。

```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.
```

此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！



#### **unique_ptr（替换auto_ptr）**

unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

采用所有权模式，还是上面那个例子

```c++
unique_ptr<string> p3 (``new` `string (``"auto"``)); 
unique_ptr<string> p4;        
p4 = p3;  //此时会报错！！
```

C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个。例如：

```c++
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```



#### shared_ptr

shared_ptr实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。

shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。

成员函数：

use_count 返回引用计数的个数

unique 返回是否是独占所有权( use_count 为 1)

swap 交换两个 shared_ptr 对象(即交换所拥有的对象)

reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少

get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的



#### weak_ptr

weak_ptr 是一种不控制对象生命周期的智能指针， 它指向一个 shared_ptr 管理的对象。进行该对象的内存管理的是那个强引用的 shared_ptr。weak_ptr只是提供了对管理对象的一个访问手段。weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的构造和析构不会引起引用记数的增加或减少。

**weak_ptr是用来解决shared_ptr相互引用时的死锁问题**，如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0，资源永远不会释放。它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。



#### 循环引用

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。
