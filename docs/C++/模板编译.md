### 问题

 “传统”编程方法(在*.h文件声明，在*.cpp文件中定义)不能用于模板。

```c++
// array.h
template <typename T, int SIZE>
class array
{
    T data_[SIZE];
    array (const array& other);
    const array& operator = (const array& other);
public:
    array(){};
    T& operator[](int i) {return data_[i];}
    const T& get_elem (int i) const {return data_[i];}
    void set_elem(int i, const T& value) {data_[i] = value;}
    operator T*() {return data_;}      
};  
```

然后在main.cpp文件中的主函数中使用上述模板：

```c++
// main.cpp
#include "array.h"

int main(void)
{
array<int, 50> intArray;
intArray.set_elem(0, 2);
int firstElem = intArray.get_elem(0);
int* begin = intArray;
}
```

这时编译和运行都是正常的。程序先创建一个含有50个整数的数组，然后设置数组的第一个元素值为2，再读取第一个元素值，最后将指针指向数组起点。



将array.h文件分裂成为array.h和array.cpp二个文件(main.cpp保持不变)

```c++
// array.h        
template <typename T, int SIZE>
class array
{
      T data_[SIZE];
      array (const array& other);
      const array& operator = (const array& other);
  public:
      array(){};
      T& operator[](int i);
      const T& get_elem (int i) const;
      void set_elem(int i, const T& value);
      operator T*();      
};  
```

```c++
// array.cpp
#include "array.h"

template<typename T, int SIZE> T& array<T, SIZE>::operator [](int i)
    {
    return data_[i];
    }

template<typename T, int SIZE> const T& array<T, SIZE>::get_elem(int i) const
    {
    return data_[i];
    }

template<typename T, int SIZE> void array<T, SIZE>::set_elem(int i, const T& value)
    {
    data_[i] = value;
    }
template<typename T, int SIZE> array<T, SIZE>::operator T*()
    {
    return data_;
    }
```

编译时会出现3个错误。



### 模板编译

​		当编译器遇到一个模板定义时，并不生成代码。只有当我们实例化出一个模板的特定版本时，编译器才会生成代码。当我们使用模板是时，编译器才生成代码，这个特性决定了我们如何组织代码以及错误何时被检测到。

​		通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类成员函数的定义放在源文件中。

​		模板则不同：为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

**函数模板和类成员模板的定义通常放在头文件中。**