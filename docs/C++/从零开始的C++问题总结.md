1.在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？

A：构造从上至下，析构从下而上。

2.在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？

A：构造函数不需要，析构函数一定要。

3.什么是 C++ 多态？C++ 多态的实现原理是什么？

A：C++中虚函数的作用主要是为了实现多态。在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象的时候，通过它能够调用到子类改写的函数，而不是父类本身。

这是运行期多态，即父类指针只有在程序运行时才能知道所指的真正类型是什么。

4.什么是虚函数？虚函数的实现原理是什么？ 

5.什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？ 

6.菱形继承（类 D 同时继承 B 和 C，B 和 C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？ 

class与struct的区别

使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
class 可以使用模板，而 struct 不能。  

另外，时至今日，你一定要熟悉 C++11/14/17 常用的语言特性和类库，这里简单地列一下： 
  统一的类成员初始化语法与std::initializer_list<T> 
  注解标签（attributes） 
  final/override/=default/=delete
  语法auto
  关键字Range-based 
  循环语法结构化绑定stl 
  容器新增的实用方法
  std::thread
  线程局部存储 thread_local
  线程同步原语 std::mutex、std::condition_variable 等
  原子操作类
  智能指针类
  std::bind/std::function



### extern



### Dynamic_cast

一般认为子类对象大小>=父类对象大小。因为子类可以扩展父类，可以增加成员变量。如果一个子类增加了成员变量，那么它的对象的内存空间会大于父类对象。这时一个实际指向父类的指针，如果被强制转化为子类对象指针，当使用这个指针时可能会导致越界访问非法内存。相反，为何子类指针可以转换为父类指针？因为父类指针需要的，子类对象都有，不会出现非法内存访问。

这就是dynamic_cast不一定成功的原因。如果一个实际指向子类对象的指针被转换成了父类指针，然后再用dynamic_cast转换回来，一定能成功，而一个实际指向父类对象的指针，被dynamic_cast转换为子类指针，一定会失败。



### Static

类的静态成员是所有对象共享的，一开始就分配了，以后固定而不会再分配空间。

静态函数不允许调用类的普通变量，只能访问类的静态变量

全局变量、静态全局变量、静态局部变量——内存的全局数据区，局部变量——栈区

- 全局变量在整个工程文件中都有效
- 静态全局变量只在定义它的文件有效
- 静态局部变量只在定义它的函数内有效，只分配一次内存，函数返回后变量不会消失。
- 全局变量和静态变量如果没有手动初始化，则编译器初始化为0，局部变量不知道

staic成员变量在类外初始化，因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致每个对象都包含该静态成员，这就矛盾了。



### this

- this指针的一般形式为（假如类类型是A，当然与类类型相关）：A * const ，也就是说this指针是一个常量指针（指针的地址值为常量）
- 在类的非const成员函数中，this的类型为一般形式，即 A * const
- 在类的const成员函灵数，this的类型为：const A * const，即指向常量对象的常量指针

const_cast转换是去掉所指向对象的常量性，使得const成员函数可以修改数据成员或调用非const成员函数（本来是不允许的）；但不推荐用这样的方法，如果只是修改数据成员，请用mutable关键字。