[TOC]



## 封装，继承，多态

封装：把对象的属性和行为（数据）封装为一个独立的整体，尽可能隐藏对象的内部实现细节；

继承：一种代码重用机制，子类可以直接使用父类的部分数据和方法，可以有选择的扩展。比如鸟是动物，但鸟扩展了飞行的能力。

多态：在不同的条件下表现出不同的状态，可以简单地理解为同一条函数调用语句能调用不同的函数，或者说不同的对象调用相同的方法可以表现出不同的行为。比如动物实现了say()方法，猴子、马等动物重写了say()方法来表现不同的交流语言。表现形式：重载与重写；

C++支持两种多态性：编译时多态（通过重载函数实现），运行时多态（通过虚函数实现，重写虚函数时一定要保证函数的返回值，参数列表，函数名称完全一致）。

 

## C++内存划分（内存管理）

在C++中内存分为5个区，分别是堆、栈、全局（静态）存储区、常量存储区和代码区。

堆：堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc，C++使用new从堆上分配内存，使用free和delete释放已分配的对应内存。

栈：在执行函数时，函数内的局部变量都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

全局（静态）存储区：这块内存是在程序编译的时候就已经分配好的，在程序整个运行期间都存在。例如全局变量，静态变量。

常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量(const)，不允许修改，程序结束后由系统释放。

代码区：存放函数体（类成员函数和全局区）的二进制代码。

 

## 内存对齐（类或结构体）

\1. 什么是对齐

字节对齐每个成员变量的起始位置是都是从某些特定的位置开始的。这就是对齐。单纯从语言上描述对齐有些枯燥难以理解，下文将配以例子说明C/C++是基于什么样的规则对齐的。

\2. 为什么对齐

系统从某些特定的位置开始读数据非常快，而从其它位置读数据会慢很多。为了使程序运行速度尽可能地快。

默认对齐值

\3. 64位系统默认对齐8，32位系统默认对齐4。

\4. 结构体类型与类对象的对齐原则：使用成员当中最大的对齐字节来对齐。比如int a的对齐字节为4，比char,short都大，所以对象的对齐字节为4.

 

## C++编译过程（预处理、编译、汇编、链接）

1、预处理：条件编译，头文件包含，宏替换的处理，生成.i文件。

a.处理所有的注释，以空格代替。

b.将所以#define删除，并展开所有的宏定义，字符串替换。

c.处理条件编译指令#if，#ifdef，#elif，#else，#endif

d.处理#include，并展开被包含的文件，把头文件中的声明，全部拷贝到文件中。

e.保留编译器需要使用的#pragma指令

 

2、编译：将预处理后的文件转换成汇编语言，生成.s文件

编译过程分为6个阶段分别是：词法分析、语法分析、语义分析、中间代码产生、优化、目标代码生成。

a.词法分析是编译过程的第一个阶段。这个阶段的任务是输入源程序,对构成源程序的字符串进行扫描和分解,识别出单词符号。再依据构词规则把单词符号分为标识符、保留字、算符、界符等。

b.语法分析是编译过程的第二个阶段。这个阶段的任务是在词法分析的基础上将单词序列分解成各类语法单位，如“程序”、“语句”、“表达式”等。

c.语义分析是审查源程序有无语义错误，为代码生成阶段收集类型信息。例如，语义分析的一个工作是进行类型审查，审查每个算符是否具有语言规范允许的运算对象，当不符合语言规范时，编译程序应报告错误。

语义检查:

1.变量或过程未经声明就使用2.变量或过程名重复声明3.运算分量类型不匹配4.操作符与操作数之间的类型不匹配5.数组下标不是整数6.对非数组变量使用数组访问操作符7/对非过程名使用过程调用操作符8.过程调用的参数类型或数目不匹配9.函数返回类型有误

d.中间代码生成是对各类语法单位按语言的语义进行初步翻译生成中间代码。中间代码的设计原则主要有两点：1.容易生成；2.容易将它翻译成目标代码

e.优化是编译过程的第五个阶段。这个阶段的任务是对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码，即省时间，省空间。

f. 目标代码产生

它的任务是把中间代码变换成特定机器上的目标代码，它的工作依赖于硬件系统结构和机器指令的含义。

目标代码三种形式1.汇编指令代码:需要进行汇编2.绝对指令代码:可直接运行3.可重新定位指令代码:需要链接

 

3、汇编：汇编语言变为机器语言，生成.o的文件

 

4、链接：将编译阶段生成的文件连接为一个整体文件，生成可执行程序

静态链接和动态链接的区别：链接的时机不一样。静态链接是在形成可执行程序前，把要链接的内容已经链接到了生成的可执行文件中，就算把静态库删除也不会影响可执行程序的执行；而动态链接的进行则是在程序执行时，在执行的过程中，再去找要链接的内容，生成的可执行文件中并没有要链接的内容，所以当你删除动态库时，可执行程序就不能运行。

 

## C++四种强制类型转换（static_cast, const_cast, dynamic_cast, reinterpret_cast）

\0. C风格的显式强制转换（不管什么类型的转换都可以使用） Typename B = (Typename) A

\1. static_cast，主要用法如下：

（1）用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。

   进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；

   进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。

 （2）用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。

    （3）把空指针转换成目标类型的空指针。

    （4）把任何类型的表达式转换成void类型。

\2. const_cast，上边的 static_cast 不能将 const int* 转成 int*，const_cast 就可以，用法为 const_cast<type-i> (expression)，也就是说，const_cast<>里边的内容必须是引用或者指针，相当于为C++ 提供了一种修改const变量的方式，一般不推荐使用。

\3. reinterpret_cast，主要有三种强制转换用途：

  （1）改变指针或引用的类型

  （2）将指针或引用转换为一个足够长度的整形

  （3）将整型转换为指针或引用类型。

  用法为 reinterpret_cast <type-id> (expression)。

  type-id 必须是一个指针、引用、算术类型、函数针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。

\4. dynamic_cast，用法为 dynamic_cast<type-id> (expression)。

  几个特点如下：

  （1）其他三种都是编译时完成的，dynamic_cast 是运行时处理的，运行时要进行类型检查。

  （2）不能用于内置的基本数据类型的强制转换.

  （3）dynamic_cast 要求 <> 内所描述的目标类型必须为指针或引用。dynamic_cast 转换如果成功的话返回的是指向类的指针或引用，转换失败的话则会返回 nullptr

  （4）在类的转换时，在类层次间进行上行转换（子类指针指向父类指针）时，dynamic_cast 和 static_cast 的效果是一样的。在进行下行转换（父类指针转化为子类指针）时，dynamic_cast 具有类型检查的功能，比 static_cast 更安全。 向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。在C++中，编译期的类型转换有可能会在运行时出现错误，特别是涉及到类对象的指针或引用操作时，更容易产生错误。Dynamic_cast操作符则可以在运行期对可能产生问题的类型转换进行测试。

  （5）使用 dynamic_cast 进行转换的，基类中一定要有虚函数，否则编译不通过（类中存在虚函数，就说明它有想要让基类指针或引用指向派生类对象的情况，此时转换才有意义）。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表中，只有定义了虚函数的类才有虚函数表

 

## C++常用设计模式（单例模式、工厂模式等）

单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点，能够避免一个全局使用的类频繁地创建与销毁。

应用场景：比如Windows的Task Manager（任务管理器）就是很典型的单例模式。在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。

单例模式的实现：

1、将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；

2、在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

 

线程安全的懒汉单例模式：（不安全的将加锁语句和解锁语句删除即可。不加锁的话在多线程下会出现问题，当同一时候有两个或以上的线程进入getSingleton()这个方法时，因为刚开始时singleton是null，而几个线程都是第一时间到达了这个方法里，所以if条件都满足，就会出现新建出不是唯一的Singleton对象）

class Singleton {

public:

   static Singleton* getInstance();

private:

   Singleton(){}                  //构造函数私有

   Singleton(const Singleton&) = delete;      //明确拒绝

   Singleton& operator=(const Singleton&) = delete; //明确拒绝

   static Singleton* m_pSingleton;

};

 

Singleton* Singleton::m_pSingleton = NULL;

 

Singleton* Singleton::getInstance() {

  if(m_pSingleton == NULL)

  {

​    mutex.lock(); //加锁

​    if(m_pSingleton == NULL) {

​      m_pSingleton = new Singleton();

​    }

​    mutex.unlock(); //解锁

  }

  return m_pSingleton;

}

 

饿汉单例模式：线程安全，注意一定要在合适的地方去delete它

class Singleton {

public:

   static Singleton* getInstance();

private:

   Singleton(){}                  //构造函数私有

   Singleton(const Singleton&) = delete;      //明确拒绝

   Singleton& operator=(const Singleton&) = delete; //明确拒绝

 

   static Singleton* m_pSingleton;

};

 

Singleton* Singleton::m_pSingleton = new Singleton();

 

Singleton* Singleton::getInstance()

{

   return m_pSingleton;

}

 

工厂模式：简单工厂模式：主要特点是需要在工厂类中做判断，从而创造相应的产品，当增加新产品时，需要修改工厂类。工厂方法模式是指定义一个创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

 

适配器模式：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。

 

中介者模式：用一个中介对象来封装一系列的对象交互，中介者使每个对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之前的交互。

 

组合模式：将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

 

策略模式：是指定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。使得算法可以独立于使用它的客户而变化，也就是说这些算法所完成的功能是一样的，对外接口是一样的，只是各自现实上存在差异。

 

原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

 

## 栈和堆的区别

1、数据结构中堆栈区别

堆（数据结构）：堆可以被看成是一棵树，如：堆排序。

栈（数据结构）：一种先进后出的数据结构。

2、操作系统中堆栈空间分配区别

栈：由操作系统（编译器）自动分配释放，用来存放函数的参数值，局部变量的值等。操作方式类似于数据结构中的栈。

堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。

3、堆栈缓存方式区别

栈使用的是一级缓存， 它们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

 

## strlen和sizeof的区别

1.sizeof是运算符，strlen是函数。

2.sizeof是在编译时计算的，计算的是占内存空间的大小，strlen是运行时计算的，求的是实际长度。例如，char str[10] = "12345" ,在32位机器下,为sizeof ( char ) *10=10 ,而其strlen大小则是在运行期确定的,所以其值为字符串的实际长度5。

3.strlen只能用char*作参数，sizeof可以用类型或者函数作为参数，以函数作为参数时，如int g( ) ,则sizeof(g( ) )的值等于sizeof (int)，32位为4。

 

## malloc和new的区别

1、申请的内存所在位置不同

new操作符从自由存储区（free store）上为对象动态分配内存空间。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。

malloc函数从堆上动态分配内存。堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

2、返回类型安全性不同

new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。

malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。

3、内存分配失败时的返回值不同

new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL。

malloc分配内存失败时返回NULL。

4、是否需要指定内存大小不同

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。

malloc则需要显式地指出所需内存的尺寸。

 

## const与#define的区别

可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：

（1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。

（2）有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。

（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。因此const比define节省空间。

（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。

 

## define与typedef的区别

1.原理不同。

typedef是关键字，它是在编译阶段处理的，所以它有检查的功能。

\#define是预处理指令，只是在预处理阶段起到一个字符串替换的作用，是不对正确性进行检查的。

2.功能不同

typedef是用来定义type就是类型的，比如数据类型int, char，还有自定义类型，主要是为了方便记忆。

\#define既可以为类型来取一个别名，也可以定义常量、变量等等。

## const和static的用法

**const****用法：**

1、const修饰变量

const修饰变量，可以使变量具有常属性，也就是该变量在以后的使用中其值都不能进行改变。

2、const修饰指针指针

int const *p == const int *p; //指针p本身可以修改，但p指向的内容不能修改；

int *const p; //指针p本身不能修改，但是p指向的内容可以修改

int const * const p == const int * const p; //指针p本身和p指向的内容都不能修改

3、const保护函数参数不被改变

用const修身函数的参数，可以保证该参数的值在函数内部不被改变。

4、const修饰函数返回值

const修饰函数的返回值，防止函数的返回值被修改

5、const修饰类成员函数

const可以修饰类成员函数，防止类成员函数中除了static成员之外的其他成员被修改。

6、const修饰类的成员变量

类的成员变量可以分为静态的和非静态的，如果const修饰的是静态的成员变量，可以在构造函数中对该变量进行初始化；如果const修饰的是静态的成员变量，则需要在类外对该变量进行初始化。

7、const和extern

const修饰的变量只能在该程序的本文件中使用，不能在该程序的其他文件中使用。

要想const定义的对象变量能被其他文件调用,定义时必须使用extern修饰为：

extern const int val;

 

**static****用法：**

static修饰静态成员，是在编译阶段就分配空间。即对象还没有创建时，就已经分配空间。不管这个类创建了多少个对象，静态成员只有一个拷贝，这个拷贝被所有属于这个类的对象共享。如果一个类的成员，既要实现共享，又要实现不可改变，那就要用static const修饰。

静态成员变量必须在类中声明，在类外定义。除非是静态常量成员(static const修饰)，才可以在类内初始化。

静态成员函数的目的是操作静态成员数据，不可以访问非静态成员数据。

普通成员函数既可以操作非静态成员数据，也可以操作静态成员数据。

 

**static****为什么只初始化一次？**

static修饰的东西放在静态存储区，生命周期是和整个程序保持一致的。所以只需要初始化第一次，就能到程序结束。

 

## stuct和体union联合的区别

主要区别是：结构体内部数据时是分开存储的，而联合体所有数据是存储在一个地址空间内。

在 C 语言中，结构体（struct）是一个或多个变量的集合，这些变量可能为不同的类型，为了处理的方便而将这些变量组织在一个名字之下。由于结构体将一组相关变量看作一个单元而不是各自独立的实体，因此结构体有助于组织复杂的数据，特别是在大型的程序中。

共用体（union），也称为联合体，所有成员共享内存空间，即所有的成员内存起始地址都是相同的，大小由最大的那个成员决定，在初始化的时候只初始化一个成员就够了，在联合的初始化列表中只有一个初始化器(写多了会报错)，如果不指定要初始化的元素，默认是初始化第一个成员。

 

## volatile关键字的作用（多线程编程）

volatile关键字作用主要是用来进行多线程编程，在单线程中那就是只能起到限制编译器优化的作用。

当多个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止编译器自动优化，把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

 

## 指针的用法

int *p = &a; // p指向变量a。

int **p; //双重指针，就是指向指针的指针。

int (*p)[n]; //p是指向一维数组的指针。

int * p[n] //指针数组，由n个指针组成的数组。

int *fun(int x,int y); //指针函数，即返回值是一个指针。

int max(int x, int y) {return x > y ? x : y;} 

int (* p)(int, int) = & max; // 函数指针，指向函数的指针

另外还有空指针和野指针。 

 

## 数组名和指针的区别

数组名的本质是数据结构

区别1：

sizeof（指针） 它的大小永远和你分配了多少内存无关，在64位机下，指针占8个字节

而sizeof（数组名) 却可以得出数组大小

区别2：

char str[5];

str="ABCD“;

显然编译错误，数组名不能拿来赋值

区别3：

数组名不能自增或自减，而指针可以。

 

## 引用和指针的区别

这个问题其实很复杂。C语言里有指针，C++在继承C语言指针的基础上提出了引用。

**首先在概念层面上**：指针也是一种变量，是用来存储内存地址的一种变量，可以通过指针来访问它指向的内存地址中的内容（数据）；而引用指的是给变量起一个别名，使用这个别名就相当于直接使用这个变量。

**然后在使用它们时候的语法层面上**，我们通常说，比如：

1.引用定义时必须初始化，指针不用。

2.指针可以改，引用不可以。

3.引用不能为空，指针可以。

4.Sizeof(引用)计算的是它引用的对象的大小，而sizeof(指针)计算的是指针本身的大小。

5.如果返回的是动态分配的内存或对象，必须使用指针，使用引用会产生内存泄漏。

**但是在编译层面，**引用的底层也是指针实现的，内置类型指针传递和引用传递的汇编代码是一样的。也就是说引用和指针在本质上是很类似的，编译器会把引用当成一个const的指针来操作。所以我之前看C++之父有提到，说C++提出引用最主要的目的是为了支持运算符的重载，因为C语言是不支持运算符重载的（运算符重载必须在语言级层面上才能支持）。另外我个人觉得，使用引用还有一点好处就是代码看起来会比简洁，容易阅读。

 

## 虚函数是什么，构造和析构可以虚吗，哪些函数不能是虚函数

虚函数是以virtual关键字声明的基类函数。如果在基类中将某个函数指定为virtual，并且派生类中有另外一个该函数的定义，则编译器将知道我们不想静态连接该函数。我们真正需要的是基于调用该函数的对象种类，在程序的特定位置选择调用哪一个函数。

**构造函数不能为虚函数：**

因为函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。

**析构函数可以为虚函数**：

并且当要使用基类指针或引用来调用子类时，最好将基类的析构函数声明为虚函数，否则可能存在内存泄露的问题。

 

**以下函数不能作为虚函数：**

1）友元函数，它不是类的成员函数

2）全局函数

3）静态成员函数，它没有this指针

3）构造函数，拷贝构造函数，以及赋值运算符重载（可以但是一般不建议作为虚函数）

 

## 虚函数的实现机制：虚函数表是什么

每一个有虚函数的类都有一个虚函数表，该类构造的任何对象中都放着该虚函数表的指针。

C++可以用虚函数表来实现动态绑定：

比如我现在有一个父类的指针，它指向的是一个子类的对象，那么当我使用这个指针来调用被多态函数的时候，就算我指针是父类的，调用的还是实际对象的函数。

 

## 虚函数和纯虚函数的区别

有纯虚函数的类是抽象类，不能生成对象，只能派生。他派生的类的纯虚函数没有被改写，那么，它的派生类还是个抽象类。

虚函数必须实现，纯虚函数不能实现。

 

## 浅拷贝和深拷贝的区别

浅拷贝和深拷贝主要区别就是复制指针时是否重新创建内存空间。

拷贝构造函数分为浅拷贝和深拷贝两种，在我们没有自己定义拷贝构造函数时，会在拷贝对象时调用默认拷贝构造函数，进行的是浅拷贝，即对指针拷贝后会出现两个指针指向同一个内存空间。

 

## 什么是友元？

( 1 )友元函数：友元函数可以访问类中的私有或保护成员。

( 2 )友元类：友元类中的成员函数可以访问本类的私有或保护成员。

 

## 父类的构造函数/析构函数不能被子类继承

 

## 类的成员变量初始化顺序

1.用初始化列表初始化时，只与定义成员变量的顺序有关，与构造函数中初始化成员列表的顺序无关，

因为成员变量的初始化次序是根据变量在内存中次序有关，而内存中的排列顺序是编译阶段根据变量的定义次序决定的。

2.在构造函数内初始化时，与成员变量在构造函数中的位置有关。

特殊：const成员常量必须在构造函数的初始化列表中初始化；static成员变量必须在类外初始化。

 

## 构造函数/析构函数调用顺序

C++构造函数按下列顺序被调用：

(1)任何虚基类的构造函数按照它们被继承的顺序构造；

(2)任何非虚基类的构造函数按照它们被继承的顺序构造；

(3)任何成员对象的构造函数按照它们声明的顺序调用；

(4)类自己的构造函数。

 

析构函数调用顺序刚好相反。

 

## C++的STL（容器、迭代器、算法、仿函数、适配器、分配器）

\1. 容器，一种数据结构，如list(双向列表)，vector(动态数组)，和deque(双端队列) ，以模板类的方法提供。为了访问容器中的数据，常用的包括vector、list、deque、set、map、multiset、multimap等。可以使用由容器类输出的迭代器。

\2. 迭代器，提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；

​    \* 迭代器可能会失效。如序列性容器 (vector和list和deque)中，erase迭代器不仅使所指向被删元素的迭代器失效，而且使被删元素之后的所有迭代器失效，所以不能使用erase(iter++)的方式，而是让erase的返回值为下一个有效的迭代器。关联性容器(map和set)中，erase迭代器只是被删元素的迭代器失效，但是返回值为void，所以要采用erase(iter++)的方式删除迭代器，

\3. 算法，是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；

\4. 仿函数，行为类似函数，就是使一个类的使用看上去象一个函数，具有可配接性。它的具体实现就是通过在类中重载了operator()，使这个类具有了类似函数的行为，就是一个仿函数类了。一般函数指针、回调函数可视为狭义的仿函数。以操作数的个数划分，可分为一元和二元仿函数；以功能划分，可分为算术运算、关系运算、逻辑运算三大类。这部分内建的仿函数，均放在头文件里，使用时需引入头文件。

\5. 适配器(adapter)，一种用来修饰容器(container)或仿函数(functor)或迭代器(iterator)接口的东西。如queue和stack。它们的底部完全借助deque（双端队列），所有操作都由底层的deque供应。改变functor接口者，称为functor adapter，改变container接口者，称为container adapter；改变iterator接口者，称为iterator adapter。

\6. 分配器(allocator)，负责空间配置与管理，一个实现了动态空间配置、空间管理、空间释放的模板类。

 

## vector（和list区别、扩容机制、push_back和emplace_back的区别）

**vector****和list****的区别：**

\1. vector，在堆上分配一段连续的内存空间，和数组类似，能够高效地进行随机存取，时间复杂度是O(1)。但插入和删除操作时，会造成内存块的拷贝，因此时间复杂度为O(n)。另外，当数组内存空间不够时，会重新申请一块两倍的内存空间并进行拷贝。

\2. list是由双向链表实现的，因此内存空间是不连续的，只能通过指针访问数据，所以list的随机存取效率很低，时间复杂度为O(n)。不过由于链表自身的特点，能够进行高效的插入和删除。

\3. vector和list对于迭代器的支持不同。相同点在于，vector< int >::iterator和list< int >::iterator都重载了 “++”操作。不同点在于，在vector中，iterator支持 +、+=、<等操作。而list中则不支持。

 

**应用场景区别：**

vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。

list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

 

**扩容机制：**

push_back按两倍来扩容，因为push_back每次都是只插入一个数据。insert的话，因为可以一次插入多个数据，要复杂一些，比如新插入数据比按2倍扩容后还大，所以具体会有一个公式来判断扩容多少。

 

**vector****中push_back****和emplace_back****的区别：**

尽量使用emplace_back代替 push_back。

push_back()向容器中加入一个右值元素(临时对象)时，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放，造成临时变量申请资源的浪费。

emplace_back直接在容器内构造对象，不用拷贝再使用。引入了右值引用和转移构造函数后，调用时就会调用移动构造函数。可以在插入的时候直接构造，此时只需要构造一次即可。这就是c++11 新加的emplace_back。

 

## 平衡二叉树AVL和红黑树

AVL和红黑树都是一种特殊的二叉查找树。普通的二叉查找树在极端情况（绝对有序）可退化成链表，此时的增删查效率都会比较低下。为了避免这种情况，就出现了一些自平衡的查找树，比如 AVL，红黑树等。这些自平衡的查找树通过定义一些性质，在插入和删除的时候，根据情况进行调整，以降低二叉树的高度，将任意节点的左右子树高度差控制在规定范围内，以达到平衡状态。

AVL树的特性：任何一个节点的左子支高度与右子支高度之差的绝对值不超过1。

Windows对进程地址空间的管理用到了AVL树。

红黑树的特性：

（1）每个节点都是黑色或红色。

（2）根节点和所有的叶子节点都是黑色。

（4）如果一个节点是红色的，则它的子节点必须是黑色的。

（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点（该数目称为黑高）。

红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(logn)，效率非常之高。

例如C++ STL中的set、map，（以及Linux虚拟内存的管理）都是通过红黑树去实现的。

 

## map和unordered_map的底层、优缺点、适用场景

**底层：**

map和unordered_map是字典结构，通过键值对（key-value）存储数据的。（字典的优势在于值（value）可以直接通过键（key）来访问，方便快捷）

但它们底层的数据结构不同：

map的底层是红黑树。红黑树是一种平衡二叉查找树的变体结构，它的左右子树的高度差有可能会大于 1。所以红黑树不是严格意义上的平衡二叉树AVL，但对之进行平衡的代价相对于AVL较低， 统计性能的平均要强于AVL。红黑树具有自动排序的功能，因此在map中的元素排列都是有序的。在map中，红黑树的每个节点就代表一个元素，因此实现对map的增删改查，也就是相当于对红黑树的操作。对于这些操作的复杂度都为O(logn)，复杂度即为红黑树的高度。

unordered_map基于哈希表（也叫散列表）实现的。哈希表通过散列函数把关键码值映射到表中一个位置，能够根据关键码值来直接进行访问，以加快查找的速度。散列表使得unordered_map的插入和查询速度接近于O(1)（在没有冲突的情况下），但是其内部元素的排列顺序是无序的。

 

**优缺点和使用场景：**

map优点：1.元素的有序性在很多应用中都会简化很多的操作；2. 红黑树使得map的很多操作在logn的时间复杂度下就可以实现，因此效率比较高。

map缺点： 空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点、孩子节点和红/黑性质，使得每一个节点都占用大量的空间。

map适用场景：1. 对于那些有顺序要求的问题，用map会更高效一些；2. 对于单次查询时间较为敏感，必须保持查询性能的稳定性，比如实时应用等。

unordered_map优点：哈希表的查找速度快，平均接近O(1)

unordered_map缺点：1.元素无序；2.哈希表的建立比较耗费时间（需要通过散列函数，还要解决冲突）；3. 查询性能不太稳定，最坏时间复杂度可达到O(n)。

unordered_ma适用场景：要求查找速率快，且对单次查询性能要求不敏感。

 

注意：对于unordered_map或unordered_set容器，其遍历顺序与创建该容器时输入的顺序不一定相同，因为遍历是按照哈希表从前往后依次遍历的

 

## set和unordered_set的底层、优缺点、适用场景

set与unordered_set是集合结构，成员是唯一的（内部元素没有重复的值）。

 

set与unordered_set区别和map与unordered_map区别类似：

set基于红黑树实现，红黑树具有自动排序的功能，因此set内部所有的数据，在任何时候都是有序的。

unordered_set基于哈希表，数据查找、插入和删除的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。

 

set适用场景：1. 需要有序的数据。2. 需要方便查找元素的前驱/后继。

unordered_set适用场景：1. 需要保留一组不同的元素，不需要排序。2. 需要单个元素访问，即没有遍历。

 

## C++11新特性（nullptr, auto, lambda, 右值引用, 移动语义, 智能指针, 多线程编程等）

\1. 加入了一些“语法糖”：如nullptr, auto自动类型推导，lambda表达式等。

\2. 右值引用和移动语义（move函数）

\3. 智能指针

\4. 多线程编程：thread库及其相配套的同步原语mutex, lock_guard, condition_variable, 以及异步std::furture

 

nullptr: 解决二义性问题。NULL会被直接解释成0；而nullptr在C++11中就是代表空指针，不能被转换成数字。

auto: C语言中的auto只是与static做区分，一个变量默认就是auto。因为很少有人去用这个东西，所以在C++11中就把原有的auto功能给废弃掉了，而变成了现在的自动类型推导关键字。比如写一个auto a = 3, 编译器就会自动推导a的类型为int. 在遍历某些STL容器的时候，不用去声明那些迭代器的类型，也不用去使用typedef就能很简洁的实现遍历了。

auto的使用有以下两点必须注意：

①auto声明的变量必须要初始化，否则编译器不能判断变量的类型；

②auto不能被声明为返回值、形参和模板参数。

lambda表达式: 是匿名函数，可以认为是一个可执行体functor，语法如：auto add = [](int a, int b) {return a + b};

​    使用场景：排序中的比较操作；在一个单独的线程中运行代码等。

 

## C++11 右值引用、移动语义、移动构造函数

右值引用：

在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（生命周期短）。

C++11之前的引用只能操作等号左边的左值。C++11引入右值引用，用 "&&" 表示。和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值（如不能是变量只能是数字）进行初始化。

和左值引用不同的是： 

\1. 一般的左值引用用来其别名，常量左值引用常用于类中构建拷贝构造函数；而右值引用一般用于移动语义、完美转发。

\2. 右值引用一般不能绑定左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。

\3. 左值持久，右值短暂（右值要么是字面值常量，要么是表达式求值过程中创建的临时变量）。

 

移动语义：

在面向对象中，有的类是可以调用拷贝构造函数来拷贝，但有的类的对象或者说类的资源是独有的，比如IO、 unique_ptr等，他们不可以复制，但是可以把资源交出所有权给新的对象，称为可以移动的。

C++11最重要的一个改进之一就是引入了move语义，这样在一些对象的构造时可以获取到已有的资源（如内存）而不需要通过拷贝，申请新的内存，这样移动而非拷贝将会大幅度提升性能。比如有些右值准备析构，这个时候我们用移动构造函数可以接管他们的资源。

 

移动构造函数：

当用户使用左值（非右值）初始化类对象时，会调用拷贝构造函数。用右值初始化类对象时，会调用移动构造函数；，这样可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

 

## C++智能指针（auto_ptr, shared_ptr、unique_ptr、scoped_ptr、weak_ptr）

智能指针主要是基于C++的RAII（资源分配即初始化）特性，在对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。主要包括auto_ptr, shared_ptr、unique_ptr、weak_ptr。

​    auto_ptr一般不使用，是C++标准库中(<utility>)为了解决资源泄漏的问题提供的一个智能指针类模板（注意：这只是一种简单的智能指针），两个auto_ptr对象不会同时指向同一块内存块，也就是不可以共享，用拷贝构造的时候会直接转移。

shared_ptr是可以共享的，就是多个智能指针可以指向相同对象，同时记录当前内存资源被多少个智能指针引用，相关的资源会在“最后一个引用被销毁”时候释放。可以通过成员函数use_count()来查看资源的所有者个数。

对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

​       shared_ptr存在的问题：

\1. 线程安全问题：一个 shared_ptr可被多个线程同时读取；如果要从多个线程读写同一个 shared_ptr 对象，那么需要加锁。

\2. 循环引用问题： 循环引用简单来说就是：两个对象互相使用一个shared_ptr成员变量指向对方的会造成循环引用。导致引用计数失效。即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

​    unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。unique_ptr指针本身的生命周期从创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

​    scoped_ptr：不能转让管理权。也就是说，scoped_ptr禁止用户进行拷贝与赋值（除了使用reset成员函数重置内部指针所指的对象，又或者使用swap成员函数交换指针的所指的对象）。它能够保证在离开作用域后对象被自动释放。

​    weak_ptr是为了解决shared_ptr的循环引用问题而引入的一种智能指针，可以通过shared_ptr或者另一个weak_ptr对象构造，它的构造不会引起指针引用技数的增加，因为它不共享资源，也不具有普通指针的行为，只能像旁观者那样观测资源的使用情况。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，成员函数expired()=true表示被观测的资源已经不存在，成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

 

## 空类有6个函数:默认构造、默认拷贝、默认析构、赋值运算符、取址运算符、const取址运算符重载函数、移动构造