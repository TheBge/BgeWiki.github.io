[TOC]

 

## C++11新特性（nullptr, auto, lambda, 右值引用, 移动语义, 智能指针, 多线程编程等）

\1. 加入了一些“语法糖”：如nullptr, auto自动类型推导，lambda表达式等。

\2. 右值引用和移动语义（move函数）

\3. 智能指针

\4. 多线程编程：thread库及其相配套的同步原语mutex, lock_guard, condition_variable, 以及异步std::furture

 

nullptr: 解决二义性问题。NULL会被直接解释成0；而nullptr在C++11中就是代表空指针，不能被转换成数字。

auto: C语言中的auto只是与static做区分，一个变量默认就是auto。因为很少有人去用这个东西，所以在C++11中就把原有的auto功能给废弃掉了，而变成了现在的自动类型推导关键字。比如写一个auto a = 3, 编译器就会自动推导a的类型为int. 在遍历某些STL容器的时候，不用去声明那些迭代器的类型，也不用去使用typedef就能很简洁的实现遍历了。

auto的使用有以下两点必须注意：

①auto声明的变量必须要初始化，否则编译器不能判断变量的类型；

②auto不能被声明为返回值、形参和模板参数。

lambda表达式: 是匿名函数，可以认为是一个可执行体functor，语法如：auto add = [](int a, int b) {return a + b};

​    使用场景：排序中的比较操作；在一个单独的线程中运行代码等。

 

## C++11 右值引用、移动语义、移动构造函数

右值引用：

在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（生命周期短）。

C++11之前的引用只能操作等号左边的左值。C++11引入右值引用，用 "&&" 表示。和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值（如不能是变量只能是数字）进行初始化。

和左值引用不同的是： 

\1. 一般的左值引用用来其别名，常量左值引用常用于类中构建拷贝构造函数；而右值引用一般用于移动语义、完美转发。

\2. 右值引用一般不能绑定左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值。

\3. 左值持久，右值短暂（右值要么是字面值常量，要么是表达式求值过程中创建的临时变量）。

 

移动语义：

在面向对象中，有的类是可以调用拷贝构造函数来拷贝，但有的类的对象或者说类的资源是独有的，比如IO、 unique_ptr等，他们不可以复制，但是可以把资源交出所有权给新的对象，称为可以移动的。

C++11最重要的一个改进之一就是引入了move语义，这样在一些对象的构造时可以获取到已有的资源（如内存）而不需要通过拷贝，申请新的内存，这样移动而非拷贝将会大幅度提升性能。比如有些右值准备析构，这个时候我们用移动构造函数可以接管他们的资源。

 

移动构造函数：

当用户使用左值（非右值）初始化类对象时，会调用拷贝构造函数。用右值初始化类对象时，会调用移动构造函数；，这样可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

 

## C++智能指针（auto_ptr, shared_ptr、unique_ptr、scoped_ptr、weak_ptr）

智能指针主要是基于C++的RAII（资源分配即初始化）特性，在对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。主要包括auto_ptr, shared_ptr、unique_ptr、weak_ptr。

​    auto_ptr一般不使用，是C++标准库中(<utility>)为了解决资源泄漏的问题提供的一个智能指针类模板（注意：这只是一种简单的智能指针），两个auto_ptr对象不会同时指向同一块内存块，也就是不可以共享，用拷贝构造的时候会直接转移。

shared_ptr是可以共享的，就是多个智能指针可以指向相同对象，同时记录当前内存资源被多少个智能指针引用，相关的资源会在“最后一个引用被销毁”时候释放。可以通过成员函数use_count()来查看资源的所有者个数。

对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。

​       shared_ptr存在的问题：

\1. 线程安全问题：一个 shared_ptr可被多个线程同时读取；如果要从多个线程读写同一个 shared_ptr 对象，那么需要加锁。

\2. 循环引用问题： 循环引用简单来说就是：两个对象互相使用一个shared_ptr成员变量指向对方的会造成循环引用。导致引用计数失效。即A内部有指向B，B内部有指向A，这样对于A，B必定是在A析构后B才析构，对于B，A必定是在B析构后才析构A，这就是循环引用问题，违反常规，导致内存泄露。

​    unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。unique_ptr指针本身的生命周期从创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁(默认使用delete操作符，用户可指定其他操作)。可以改变智能指针所指对象，如创建智能指针时通过构造函数指定、通过reset方法重新指定、通过release方法释放所有权、通过移动语义转移所有权。

​    scoped_ptr：不能转让管理权。也就是说，scoped_ptr禁止用户进行拷贝与赋值（除了使用reset成员函数重置内部指针所指的对象，又或者使用swap成员函数交换指针的所指的对象）。它能够保证在离开作用域后对象被自动释放。

​    weak_ptr是为了解决shared_ptr的循环引用问题而引入的一种智能指针，可以通过shared_ptr或者另一个weak_ptr对象构造，它的构造不会引起指针引用技数的增加，因为它不共享资源，也不具有普通指针的行为，只能像旁观者那样观测资源的使用情况。使用weak_ptr的成员函数use_count()可以观测资源的引用计数，成员函数expired()=true表示被观测的资源已经不存在，成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

 

## 空类有6个函数:默认构造、默认拷贝、默认析构、赋值运算符、取址运算符、const取址运算符重载函数、移动构造