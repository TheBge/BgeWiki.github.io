[TOC]

21/8/24

### 剑指offer 09 两个栈实现队列

![fig1](https://assets.leetcode-cn.com/solution-static/jianzhi_09/jianzhi_9.gif)

```c++
class CQueue 
{
    stack<int> stack1,stack2;
public:
    CQueue() {};
    
    void appendTail(int value) 
    {
        stack1.push(value);
    }
    
    int deleteHead() 
    {
        // 如果第二个栈为空
        if (stack2.empty()) 
        {
            while (!stack1.empty()) 
            {
                stack2.push(stack1.top());
                stack1.pop();
            }
        } 

        if (stack2.empty()) 
        {
            return -1;
        } 
        else 
        {
            int deleteItem = stack2.top();
            stack2.pop();
            return deleteItem;
        }
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```



### 剑指offer 30 包含min函数的栈

![GIF 2021-8-6 18-17-13.gif](https://pic.leetcode-cn.com/1628245226-xNbNUW-GIF%202021-8-6%2018-17-13.gif)

```c++
class MinStack 
{
    public:
        /** initialize your data structure here. */
        MinStack() 
        {

        }
    
        void push(int x) 
        {
            orginStack.push(x);
            if(supportStack.empty() || x <= supportStack.top())
            {
                supportStack.push(x);
            }
        }
        
        void pop() 
        {
            if(orginStack.top() == supportStack.top())
            {
                supportStack.pop();
            }
            orginStack.pop();
        }
        
        int top() 
        {
            return orginStack.top();
        }
        
        int min() 
        {
            return supportStack.top();
        }
    private:
    stack<int> orginStack;
    stack<int> supportStack;
};
```



21/8/25

### 剑指24 反转链表

```c++
// 递归
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return recur(head, nullptr);           // 调用递归并返回
    }
private:
    ListNode* recur(ListNode* cur, ListNode* pre) {
        if (cur == nullptr) return pre;        // 终止条件
        ListNode* res = recur(cur->next, cur); // 递归后继节点
        cur->next = pre;                       // 修改节点引用指向
        return res;                            // 返回反转链表的头节点
    }
};
// 迭代
class Solution 
{
    public:
        ListNode* reverseList(ListNode* head) 
        {
            ListNode* pre = nullptr;
            ListNode* cur = head;
            while(cur)
            {
                ListNode* next = cur->next;
                cur->next = pre;
                pre = cur;
                cur = next;
            }
            return pre;
        }
};
```



### 剑指35 复杂链表的复制

```c++
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};
```



9/2

英特尔笔试

### 去除字符串中相同的字符

如”xzhhchhvhh“变为"xzhcv"

```c++
void deleteDuplicatedChar(char* str, )
{
    int num = strlen(str);
    for(int i = 0; i < num; i++)
    {
		for(int j = i+1; j < num; j++)
        {
            if(str[i] == str[j])
            {
                for(int l = j; l < strlen(str); l++)
                {
					str[l] = str[l+1];
                }
                j--;
            }
        }
    }
}
```



### 反转链表II

```c++
class Solution {
private:
    void reverseLinkedList(ListNode *head) {
        // 也可以使用递归反转一个链表
        ListNode *pre = nullptr;
        ListNode *cur = head;

        while (cur != nullptr) {
            ListNode *next = cur->next;
            cur->next = pre;
            pre = cur;
            cur = next;
        }
    }

public:
    ListNode *reverseBetween(ListNode *head, int left, int right) 
    {
        // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论
        ListNode *dummyNode = new ListNode(-1);
        dummyNode->next = head;

        ListNode *pre = dummyNode;
        // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点
        for (int i = 0; i < left - 1; i++) 
        {
            pre = pre->next;
        }

        // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点
        ListNode *rightNode = pre;
        for (int i = 0; i < right - left + 1; i++) 
        {
            rightNode = rightNode->next;
        }

        // 第 3 步：切断出一个子链表（截取链表）
        ListNode *leftNode = pre->next;
        ListNode *curr = rightNode->next;

        // 注意：切断链接
        pre->next = nullptr;
        rightNode->next = nullptr;

        // 第 4 步：同第 206 题，反转链表的子区间
        reverseLinkedList(leftNode);

        // 第 5 步：接回到原来的链表中
        pre->next = rightNode;
        leftNode->next = curr;
        return dummyNode->next;
    }
};
```

