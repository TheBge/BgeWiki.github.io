21/8/24

### 剑指offer 09 两个栈实现队列

![fig1](https://assets.leetcode-cn.com/solution-static/jianzhi_09/jianzhi_9.gif)

```c++
class CQueue 
{
    stack<int> stack1,stack2;
public:
    CQueue() {};
    
    void appendTail(int value) 
    {
        stack1.push(value);
    }
    
    int deleteHead() 
    {
        // 如果第二个栈为空
        if (stack2.empty()) 
        {
            while (!stack1.empty()) 
            {
                stack2.push(stack1.top());
                stack1.pop();
            }
        } 

        if (stack2.empty()) 
        {
            return -1;
        } 
        else 
        {
            int deleteItem = stack2.top();
            stack2.pop();
            return deleteItem;
        }
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj->appendTail(value);
 * int param_2 = obj->deleteHead();
 */
```



### 剑指offer 30 包含min函数的栈

![GIF 2021-8-6 18-17-13.gif](https://pic.leetcode-cn.com/1628245226-xNbNUW-GIF%202021-8-6%2018-17-13.gif)

```c++
class MinStack 
{
    public:
        /** initialize your data structure here. */
        MinStack() 
        {

        }
    
        void push(int x) 
        {
            orginStack.push(x);
            if(supportStack.empty() || x <= supportStack.top())
            {
                supportStack.push(x);
            }
        }
        
        void pop() 
        {
            if(orginStack.top() == supportStack.top())
            {
                supportStack.pop();
            }
            orginStack.pop();
        }
        
        int top() 
        {
            return orginStack.top();
        }
        
        int min() 
        {
            return supportStack.top();
        }
    private:
    stack<int> orginStack;
    stack<int> supportStack;
};
```



21/8/25

### 剑指24 反转链表

```c++
// 递归
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        return recur(head, nullptr);           // 调用递归并返回
    }
private:
    ListNode* recur(ListNode* cur, ListNode* pre) {
        if (cur == nullptr) return pre;        // 终止条件
        ListNode* res = recur(cur->next, cur); // 递归后继节点
        cur->next = pre;                       // 修改节点引用指向
        return res;                            // 返回反转链表的头节点
    }
};
// 迭代
class Solution 
{
    public:
        ListNode* reverseList(ListNode* head) 
        {
            ListNode* pre = nullptr;
            ListNode* cur = head;
            while(cur)
            {
                ListNode* next = cur->next;
                cur->next = pre;
                pre = cur;
                cur = next;
            }
            return pre;
        }
};
```



### 剑指35 复杂链表的复制

```c++
class Solution {
public:
    unordered_map<Node*, Node*> cachedNode;

    Node* copyRandomList(Node* head) {
        if (head == nullptr) {
            return nullptr;
        }
        if (!cachedNode.count(head)) {
            Node* headNew = new Node(head->val);
            cachedNode[head] = headNew;
            headNew->next = copyRandomList(head->next);
            headNew->random = copyRandomList(head->random);
        }
        return cachedNode[head];
    }
};
```

