[TOC]



## 概念

### 1、面向过程VS面向对象

​		面向对象 ( Object Oriented ) 是将现实问题构建关系，然后抽象成 **类 ( class )**，给类定义属性和方法后，再将类实例化成 **实例 ( instance )** ，通过访问实例的属性和调用方法来进行使用。

​		**“对象”是方法（函数）和数据的组合**，类的一大特点，就是它自身是包含数据的，而且不同的数据可以造就不同的实例（对象）。



**1.封装**

​		封装在语言的体现中有2点，第一点是类的封装，第二点是函数，其实二者语法体现不同，运用场景不同，但是在本质上都是对一堆面向过程的代码封装，我们只要封装一次或者说造一次轮子，后续就可以一直调用，如果说一门语言不具备封装，那么从抒写角度来看，就不具备面向对象的概念，因为你写出的代码，都是亲力亲为，一行一个步骤，很多代码段都是相同的，如果具备封装，那么轮子造一次，重复使用即可，从抒写角度来看，相对性并不是一行一个步骤，而是调用了一个轮子来实现的，所以具备面向对象的概念，当然这一切都是从代码抒写的角度提出的。从编程思想上即便写的是面向过程仍然是面向对象的思维方法论。

​		函数封装很简单就不提及了，是最简单封装代码，实现轮子的方式，类的封装是一个有机体，封装代码具备联系，整体构成一个系统单元，对外只提供一个接口，和函数一样，和函数一样调用者不知道内部实现，而在类中还提供了对方法的私有保护的开方性，内部方法可以相互调用，可以说是大型的封装。

​		不仅是个封装的概念，在代码层次上类更是聚焦于编程者的面向对象代码层次上的体现，一个对象，具备多个特征，映射于一个类具备多属性和方法，更适用于直接的实际项目开发；而用函数作为直接开发是远不及类的。

**2.继承性**

​		这个很好解释，试着考虑一下我们在设计一门语言的同时，只具备封装，这样能快速使用轮子和面向对象体现，那么还有什么方式能够比较快速的使用轮子呢，就是继承，我直接把你的功能继承遗传过来，这样的语言会更加简约而不冗余，而且在实际开发场景中，确实我们可能还要在封装一个东西，但是需要用另外一个封装体中的内容，我们是去把代码直接复制过来，还是建立一个继承性，更为简单。

**3.多态**

​		多态同一个行为具有多个不同表现形式或形态的能力。是指一个类实例（对象）的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。



### 2、指针和引用的区别，为什么要有指针和引用? 

1. 引用只是c++语法糖，可以看作编译器自动完成取地址、解引用的**常量指针**
2. 引用区别于指针的特性都是编译器约束完成的，一旦编译成汇编就和指针一样
3. 由于引用只是指针包装了下，所以也存在风险，比如如下代码:

```c++
int *a = new int;
int &b = *a;
delete a;
b = 12;    *// 对已经释放的内存解引用*
```

4. 引用由编译器保证初始化，使用起来较为方便(如不用检查空指针等)
5. 尽量用引用代替指针
6. 引用没有顶层const即`int & const`，因为引用本身就不可变，所以在加顶层const也没有意义； 但是可以有底层const即 `const int&`，这表示引用所引用的对象本身是常量
7. 指针既有顶层const(`int * const`--指针本身不可变)，也有底层const(`int * const`--指针所指向的对象不可变)
8. 有指针引用--是引用，绑定到指针， 但是没有引用指针--这很显然，因为很多时候指针存在的意义就是间接改变对象的值，但是引用本身的值我们上面说过了是所引用对象的地址，但是引用不能更改所引用的对象，也就当然不能有引用指针了。
9. 指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或--



### 3、智能指针

​		智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

​		C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。

​		对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。



**shared_ptr里引用计数器是怎么实现共享的？**

引用计数法的内部实现:

1. 这个引用计数器保存在某个内部类型中，而这个内部类型对象在shared_ptr第一次构造时以指针的形式保存在shared_ptr中

2. shared_ptr重载了赋值运算符，在赋值和拷贝另一个shared_ptr时，这个指针被另一个shared_ptr共享

3. 在引用计数归0时，这个内部类型指针与shared_ptr管理的资源一起释放

4. 此外，为了保证线程安全，引用计数器的加1和减1都是原子操作，它保证了shared_ptr由多个线程共享时不会爆掉



### 4、栈的效率为什么比堆高

堆是一个运行时数据区,类的(对象从中分配空间。由于要在运行时动态分配内存，存取速度较慢。 存在栈中的数据可以共享。

栈是编译时分配空间，而堆是动态分配（运行时分配空间），所以栈的速度快

cpu有专门的寄存器（esp，ebp）来操作栈，堆都是使用间接寻址的。栈快点



## 类

### 1、多态说一下？虚表

​		C++中虚函数是通过一张虚函数表(Virtual Table)来实现的，在这个表中，主要是一个类的虚函数表的地址表；这张表解决了继承、覆盖的问题。在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以当我们用父类的指针来操作一个子类的时候，这张虚函数表就像一张地图一样指明了实际所应该调用的函数。

​		**C++编译器是保证虚函数表的指针存在于对象实例中最前面的位置**(是为了保证取到虚函数表的最高的性能)，这样我们就能通过已经实例化的对象的地址得到这张虚函数表，再遍历其中的函数指针，并调用相应的函数。



### 2、虚函数 

1.在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？ 



2.在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？



3.什么是 C++ 多态？C++ 多态的实现原理是什么？



4.什么是虚函数？虚函数的实现原理是什么？



5.什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？



6.菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？



7.虚函数和纯虚函数的作用和区别 



### 3、友元函数

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。



为什么会有友元函数？

结合着类的特性和类中一般成员函数，我们可以这样理解：类具有封装和信息隐藏的特性。只有类的成员函数才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将数据成员都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于参数传递，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。

为了解决上述问题，提出一种使用友元的方案。友元是一种定义在类外部的普通函数，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

友元函数的特点是能够访问类中的私有成员的非成员函数。友元函数从语法上看，它与普通函数一样，即在定义上和调用上与普通函数一样。



### 4、访问控制符

**public、protected和private**

1. public成员：能被本类的成员函数（不管是哪一种控制符声明的成员函数，都可以）、友元函数、本类的对象、其派生类的成员函数（不管是哪一种控制符声明的成员函数，都可以）；
2. protected成员：能被本类的成员函数（不管是哪一种控制符声明的成员函数，都可以）、友元函数、其派生类的成员函数（不管是哪一种控制符声明的成员函数，都可以）；
3. private成员：能被本类的成员函数（不管是哪一种控制符声明的成员函数，都可以）、友元函数；



### 5、虚函数表和虚函数指针存放在那个位置

1. 虚函数表是全局共享的元素，即全局仅有一个
2. 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表。即虚函数表不是函数，不是程序代码，不肯能存储在代码段
3. 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中



### 6、限制类对象只能在堆或者栈上建立

**1、只能建立在堆上**

编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

```c++
class A
{
public:
    A(){}
    void destory(){delete this;}
private:
    ~A(){}
};
```

试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。

**2、只能建立在栈上**

只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()设为私有即可。



### 7、空类默认产生哪些函数

```
class Empty
{
   	public:
  
      Empty(); // 缺省构造函数
  
      Empty( const Empty& ); // 拷贝构造函数
 
      ~Empty(); // 析构函数
  
       Empty& operator=( const Empty& ); // 赋值运算符
  
       Empty* operator&(); // 取址运算符
 
       const Empty* operator&() const; // 取址运算符 const
 
};
```



### 8、接口继承和实现继承

纯虚函数： 被声明为纯虚函数的类一定是作为基类来使用的，含有纯虚函数的类被称为抽象类，抽象类不能实例化对象。因此纯虚函数一般用来声明接口。其派生类必须实现这个函数。纯虚函数在基类中可以有函数实现，也可以没有。声明纯虚函数的原因是，在基类往往不合适进行实例化，比如一个shape类，中的draw方法。必须为纯虚函数，因为他不是任何一种形状。

虚函数：在基类中声明为vitual，并在一个或者多个派生类中被重新定义的函数。虚函数用于提供一类操作的统一命名。一般声明为虚函数是为了实现多态：使用基类指针指向一个派生类对象，通过这个指针调用基类和派生类的同名函数的时候，调用的是派生类中的方法（前提vitual函数肯定实现了）。

非虚函数：一般的成员函数，无virtual修饰。派生类继承函数接口及一份强制性实现。

有了这几个概念，现在解释下；接口继承与实现继承

接口继承： 派生类只继承函数接口，也就是声明。

实现继承：派生类同时继承函数的接口和实现。

总结：在设计类的时，遵循以下几点

1. 纯虚函数：要求派生类必须实现的函数，在基类中实现没有什么具体的意义。
2. 虚函数：继承类必须含有的接口，可以自己实现，也可以不实现，而采用基类的实现。
3. 非虚函数:继承类必须函数有的接口，必须使用基类实现。



## 关键字

### 1、#define和const

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。

（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。

（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。



### 2、new和malloc的区别

**1、申请的内存所在位置**

​		new操作符从**自由存储区（free store）**上为对象动态分配内存空间，而malloc函数从**堆**上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。

​		那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。

**2、返回值**

​		new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合**类型安全**性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。3.内存分配失败时的返回值

​		new内存分配失败时，会抛出bac_alloc异常，它**不会返回NULL**；malloc分配内存失败时返回NULL。

**3、是否需要指定内存大小**

使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。

**4、是否调用构造函数/析构函数**

使用new操作符来分配对象内存时会经历三个步骤：

- 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，**原始**的，未命名的内存空间以便存储特定类型的对象。
- 第二步：编译器运行相应的**构造函数**以构造对象，并为其传入初值。
- 第三部：对象构造完成后，返回一个指向该对象的指针。

使用delete操作符来释放对象内存时会经历两个步骤：

- 第一步：调用对象的析构函数。
- 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。

**5、是否可以被重载**

opeartor new /operator delete可以被重载。

**6、客户处理内存分配不足**

在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是**new-handler**。



### 3、cast

**const_cast**

1、常量指针被转化成非常量的指针，并且仍然指向原来的对象； 

2、常量引用被转换成非常量的引用，并且仍然指向原来的对象； 

**static_cast**

static_cast 作用和C语言风格强制转换的效果基本一样，没有运行时类型检查来保证转换的安全性.

**dynamic_cast**

dynamic_cast是运行时处理的，运行时要进行类型检查，不能用于内置基本数据类型间的强制转换，基类中一定要有虚函数。

**reinterpret_cast**

处理无关类型之间的转换，

reinterpret_cast用在任意指针（或引用）类型之间的转换；以及指针与足够大的整数类型之间的转换；从整数类型（包括枚举类型）到指针类型，无视大小。

只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式。



### 4、NULL和nullptr的区别

NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。



### 5、const修饰的函数作用是什么

int get() const;

1. 常量成员函数不修改对象
2. 常量成员函数在定义和声明中都应加const限定
3. 非常量成员函数不能被常量成员函数调用，但构造函数和析构函数除外
4. 常量（const对象）对象只能调用常量成员函数



### 6、const和constexpr

对于修饰Object来说：const并未区分出编译期常量和运行期常量，constexpr限定在了编译期常量。

constexpr修饰的函数，简单的来说，如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。但是，传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了。不过，我们不必因此而写两个版本，所以如果函数体适用于constexpr函数的条件，可以尽量加上constexpr。



### 7、指针数组和数组指针

指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。

数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。

```c++
int *p1[10]; // 指针数组

int (*p2)[10]; // 数组指针
```



### 8、结构体对齐

**对齐原则：**

1. 原则1：数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照`#pragma pack`指定的数值和这个数据成员自身长度中，比较小的那个进行。
2. 原则2：结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
3. 原则3：结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。





## 内存

### 1、如何避免内存泄漏

**内存泄漏情况**

1. 申请内存但是没有释放。

2. 同一块空间释放两遍，导致崩溃。

   ```c++
   void FunTest()
   {
   	int *pTest1 = (int*)malloc(10*sizeof(int));
   	int *pTest2 = (int*)malloc(10*sizeof(int));
    
   	pTest1 = pTest2;
   	free(pTest1);
   	free(pTest2);
   }
   ```

3. 程序的误操作，将堆破坏。申请的空间不足以赋值，释放导致崩溃。

   ```c++
   void FunTest()
   {
   	char *pTest1 = (char*)malloc(5);
   	strcpy(pTest1,"hello world");
   	free(pTest1);
   }
   ```

4. 当释放时传入的地址和分配时的地址不一样时，会导致崩溃。

   ```c++
   void FunTest()
   {
   	int *pTest1 = (int*)malloc(10*sizeof(int));
   	assert(pTest1 != NULL);
   	pTest1[0] = 0;
   	pTest1++;      //地址向后移动了一位
   	free(pTest1);
   }
   ```



**怎么避免内存泄漏？**

1. 不要手动管理内存，可以尝试在适用的情况下使用智能指针。

2. 使用string而不是char*。string类在内部处理所有内存管理，而且它速度快且优化得很好。

3. 在C++中避免内存泄漏的最好方法是尽可能少地在程序级别上进行new和delete调用--最好是没有。任何需要动态内存的东西都应该隐藏在一个RAII对象中，当它超出范围时释放内存。RAII在构造函数中分配内存并在析构函数中释放内存，这样当变量离开当前范围时，内存就可以被释放。

4. 使用了内存分配的函数，要记得使用其想用的函数释放掉内存。可以始终在new和delete之间编写代码，通过new关键字分配内存，通过delete关键字取消分配内存。



### 2、野指针，内存泄漏，栈溢出都是些什么?

**野指针**

1. 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

```
char *p; //此时p为野指针
```

2. 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针.

```
char *p=new char[10];  //指向堆中分配的内存首地址，p存储在栈区
cin>> p;
delete []p; //p重新变为野指针
```

3. 指针操作超越了变量的作用范围。     

```
char *p=new char[10]; //指向堆中分配的内存首地址
cin>> p;
cout<<*(p+10); //可能输出未知数据
```



**栈溢出**

栈溢出就是缓冲区溢出的一种。 由于缓冲区溢出而使得有用的存储单元被改写, 往往会引发不可预料的后果。程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区。如果向缓冲区中写入超过其本身长度的数据，以致于缓冲区无法容纳，就会造成缓冲区以外的存储单元被改写，这种现象就称为缓冲区溢出。缓冲区长度一般与用户自己定义的缓冲变量的类型有关。

- 减少栈空间的需求，不要定义占用内存较多的auto变量，应该将此类变量修改成指针，`从堆空间分配内存`。
- 函数参数中不要传递大型结构/联合/对象，应该使用`引用或指针作为函数参数`。
- 减少函数调用层次，`慎用递归函数`，例如A->B->C->A环式调用。



### 3、让你实现malloc和free的内存分配和释放，你怎么设计，考虑内存碎片问题？

会有内部碎片与外部碎片的问题，内部碎片难以消除（因为字对齐之类的问题），而外部碎片是可以消除的（如果不消除的话，外部的内存块越来越小，虽然数量多了，但是利用率会急剧下降！）

**内存池原理**

内存池的思想是，在真正使用内存之前，**预先申请分配**一定数量、大小预设的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，当内存释放后就回归到内存块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。

**内存池设计**

算法原理：

1. 预申请一个内存区chunk，将内存中按照对象大小划分成多个内存块block
2. 维持一个空闲内存块链表，通过指针相连，标记头指针为第一个空闲块
3. 每次新申请一个对象的空间，则将该内存块从空闲链表中去除，更新空闲链表头指针
4. 每次释放一个对象的空间，则重新将该内存块加到空闲链表头
5. 如果一个内存区占满了，则新开辟一个内存区，维持一个内存区的链表，同指针相连，头指针指向最新的内存区，新的内存块从该区内重新划分和申请



### 4、外碎片如何处理？

- 分配内存和释放的内存尽量在同一个函数中（避免内存泄漏）
- 尽量一次性申请较大的内存2的指数次幂大小的内存空间，而不要反复申请小内存(少进行内存的分割)
- 做内存池，也就是自己一次申请一块足够大的空间，然后自己来管理，用于大量频繁地new/delete操作。



### 5、为什么要重载operator new和operator delete

由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。

当你必须要使用new和delete的时候，你不得不控制C++中的内存分配。你需要用重载的全局new和delete代替系统的内存分配符。需要给类重载new和delete。

一个防止内存破碎的方法是从不同固定大小的内存池中分配不同类型的对象。对单个类重载new和delete，你就可以灵活的控制内存分配。



## C++11

### 1、C++中的锁有哪些，你用过哪些 

**互斥锁（Mutex）**

​		在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。

头文件：< mutex >
类型： std::mutex

用法：在C++中，通过构造**std::mutex**的实例创建互斥元，调用成员函数lock()来锁定它，调用unlock()来解锁，不过一般不推荐这种做法，标准C++库提供了**std::lock_guard**类模板，实现了互斥元的RAII惯用语法。

```c++
//用互斥元保护列表
#include <list>
#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    some_list.push_back(new_value);
}
```



**条件变量**

​		条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。

头文件：< condition_variable >

类型：std::condition_variable（只和std::mutex一起工作） 和 std::condition_variable_any（符合类似互斥元的最低标准的任何东西一起工作）。



### 2、右值引用，那你说一下左值右值的区别，C++要有左值右值?目的是什么要解决什么问题

**在C++之中的变量只有左值与右值两种：其中凡是可以取地址的变量就是左值，而没有名字的临时变量，字面量就是右值**

C++11最重要的一个改进之一就是引入了move语义，这样在一些对象的构造时可以获取到已有的资源（如内存）而不需要通过拷贝，申请新的内存，这样移动而非拷贝将会大幅度提升性能。例如有些右值即将消亡析构，这个时候我们用移动构造函数可以接管他们的资源。



### 3、为什么要有move？move最根本解决什么问题？move是怎么实现的？

std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);

**移动语义**

移动语义意味着两点：

- **原对象不再被使用**，如果对其使用会造成不可预知的后果。
- 所有权转移，资源的所有权被转移给新的对象。

移动语义通过**移动构造函数**和**移动赋值操作符**实现，其与拷贝构造函数类似，区别如下：

- 参数的符号必须为右值引用符号，即为&&。
- 参数不可以是常量，因为函数内需要修改参数的值
- 参数的成员转移后需要修改（如改为nullptr），避免临时对象的析构函数将资源释放掉。



### 4、完美转发，什么场景使用

```cpp
template <typename T>
T&& forward(typename std::remove_reference<T>::type& param)
{
    return static_cast<T&&>(param);
}

template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param)
{
    return static_cast<T&&>(param);
}
```

第一个是左值引用模板函数，第二个是右值引用模板函数。

紧接着std::forward模板函数对传入的参数进行强制类型转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。



## 其他

### 1、非static的内部类如何访问static的外部成员变量或方法？原理是什么

在静态函数的形参列表加上实例的地址。

```c++
class A
{
public:
    static void test(A *a)
    {
        a->m_a += 1;
    }
    void hello()
    {
    }
private:
    static int m_staticA;
    int m_a
};
```



### 2、编译过程

编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。

读取源程序，对之进行词法和语法分析，将高级语言指令转换为功能等效的汇编代码，源文件的编译过程包含两个过程：

**预编译**

读取源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。

宏定义指令

条件编译指令

头文件包含指令

特殊符号

**编译、优化阶段**

经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

------

汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。

------

链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件。



### 3、C和C++编译

​		由于CPP支持多态性，也就是具有相同函数名的函数可以完成不同的功能，CPP通常是通过参数区分具体调用的是哪一个函数。在编译的时候，CPP编译器会将参数类型和函数名连接在一起，于是在程序编译成为目标文件以后，CPP编译器可以直接根据目标文件中的符号名将多个目标文件连接成一个目标文件或者可执行文件。

​		但是在C语言中，由于完全没有多态性的概念，C编译器在编译时除了会在函数名前面添加一个下划线之外，什么也不会做（至少很多编译器都是这样干的）。由于这种的原因，当采用CPP与C混合编程的时候，就可能会出问题。



### 4、C++在执行main()函数之前做了哪些操作？

1. 设置栈指针
2. 初始化静态和全局变量，即data段的内容
3. 将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容
4. 全局对象初始化，在main之前调用构造函数
5. 将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数



### 5、用C实现多态

在 C 中没有类的概念，但有 struct，而且 C 中的 struct 是不允许有函数的，只允许存在变量，那是不是**函数变量**就允许存在了？！所以，**函数指针**可以给我们一些提示。

```c
struct Animal
{
     void (*move)();
};

struct Rabbit
{
     void (*move)();
};

void Animal_move()
{
     printf("Animal move.\n");
}

void Rabbit_move()
{
     printf("Rabbit move.\n");
}

// struct Animal 和 struct Rabbit 在内容上完全一致，而且变量对齐上也完全一致，可以通过将 struct Rabbit 类型的指针强制转换为 struct Animal 类型的指针，即：
int main(void)
{
     Animal *panimal;
 
     Rabbit rabbit;
 
     rabbit.move=Rabbit_move;
 
     panimal = (Animal*)&rabbit;
 
     panimal->move();
}
```

问题：

结构体是根据变量在结构体的偏移量来读取或者修改变量的。如果struct Animal 中和 struct Rabbit 中的偏移量不同，panimal->move();

可以被形象的转化为：( * (panimal+sizeof(age)) ) ();

但发现 panimal 是指向 struct Rabbit 实体的，panimal+sizeof(age) 已经指向了非法地址。

因此需要模拟多态，必须**保持函数指针变量对齐**。



### 6、可重入函数

在多任务系统下，中断可能在任务执行的任何时间发生，同时也可能在任务执行过程中发生系统调度而将执行转向另一个线程，如果一个函数的执行期间被中断后，到重新恢复到断点进行执行的过程中，函数所依赖的环境没有发生改变，那么这个函数就是可重入的，否则就不可重入。

不可重入的：

- 使用了静态数据结构；
- 调用了malloc或free；
- 调用了标准I/O函数；



### 7、符号表的重定位

​		在可重定位目标文件之中会存在一个用来放置变量和其入口地址的符号表，当编译过程中能够找到该符号的定义时就将该符号入口地址更新到符号表中否则就对该符号的地址不做任何决议一直保留到链接阶段处理。

- 在编译阶段就能够在文件中找到他们的定义，所以能够进行明确的内存地址分配。
- 在编译阶段虽然可以看到这些符号变量的声明，但却找不到他们的定义所以编译器陷入了一个决而未决的境地。

先将他们存放在符号表中但却不去为他们进行内存关联一直等到链接阶段在进行处理。

​		重定位发生于目标代码链接阶段，在链接阶段链接器就会查找符号表，当他发现了function2.cpp的符号表之中任然有没有决议的内存地址时，链接器就会查找所有的目标代码文件，一直到他找到了function1.cpp所生成的目标代码文件符号表时发现了这些没有决议的符号变量的真正内存地址，这是function2.cpp所生成的目标代码文件就会更新它的符号表，将这些尚未决议的符号变量的内存地址写进其符号表中。