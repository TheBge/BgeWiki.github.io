### 1、什么是面向对象

**面向过程（Procedure Oriented 简称PO ：如C语言）：**

从名字可以看出它是注重过程的。当解决一个问题的时候，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数） 。然后按照一定的顺序，执行完这些**方法**（每个方法看作一个过程），等方法执行完了，事情就搞定了。

**面向对象（Object Oriented简称OO ：如C++，JAVA等语言）：**

看名字它是注重对象的。当解决一个问题的时候，面向对象会把事物抽象成对象的概念，就是说这个问题里面有哪些对象，然后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题得到解决。



**什么是面向对象？**

对比面向过程，是两种不同的处理问题的角度。

面向过程更注重事情的每一个步骤及顺序，面向对象更注重事情有哪些参与者（对象）、和各自要做什么。

例如：洗衣机洗衣服

面向过程会把任务分解成一系列的步骤（函数）

- 打开洗衣机
- 放入衣服
- 放洗衣粉
- 清洗
- 烘干

面向对象会拆解出人和洗衣机两个对象

- 人：打开洗衣机、放入衣服、放洗衣粉
- 洗衣机：清洗、烘干

面向过程比较直接高效，但面向对象更易复用、扩展和维护。



### 2、虚函数 

1.在有继承关系的父子类中，构建和析构一个子类对象时，父子构造函数和析构函数的执行顺序分别是怎样的？ 



2.在有继承关系的类体系中，父类的构造函数和析构函数一定要申明为 virtual 吗？如果不申明为 virtual 会怎样？



3.什么是 C++ 多态？C++ 多态的实现原理是什么？



4.什么是虚函数？虚函数的实现原理是什么？



5.什么是虚表？虚表的内存结构布局如何？虚表的第一项（或第二项）是什么？



6.菱形继承（类D同时继承B和C，B和C又继承自A）体系下，虚表在各个类中的布局如何？如果类B和类C同时有一个成员变了m，m如何在D对象的内存地址上分布的？是否会相互覆盖？



7.虚函数和纯虚函数的作用和区别 



### 3、#define和const

（1）就起作用的阶段而言： #define是在编译的预处理阶段起作用，而const是在 编译、运行的时候起作用。

（2）就起作用的方式而言： #define只是简单的字符串替换，没有类型检查。而const有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 

（3）就存储方式而言：#define只是进行展开，有多少地方使用，就替换多少次，它定义的宏常量在内存中有若干个备份；const定义的只读变量在程序运行过程中只有一份备份。

（4）从代码调试的方便程度而言： const常量可以进行调试的，define是不能进行调试的，因为在预编译阶段就已经替换掉了。



### 4、如何避免内存泄漏

**内存泄漏情况**

1. 申请内存但是没有释放。

2. 同一块空间释放两遍，导致崩溃。

   ```c++
   void FunTest()
   {
   	int *pTest1 = (int*)malloc(10*sizeof(int));
   	int *pTest2 = (int*)malloc(10*sizeof(int));
    
   	pTest1 = pTest2;
   	free(pTest1);
   	free(pTest2);
   }
   ```

3. 程序的误操作，将堆破坏。申请的空间不足以赋值，释放导致崩溃。

   ```c++
   void FunTest()
   {
   	char *pTest1 = (char*)malloc(5);
   	strcpy(pTest1,"hello world");
   	free(pTest1);
   }
   ```

4. 当释放时传入的地址和分配时的地址不一样时，会导致崩溃。

   ```c++
   void FunTest()
   {
   	int *pTest1 = (int*)malloc(10*sizeof(int));
   	assert(pTest1 != NULL);
   	pTest1[0] = 0;
   	pTest1++;      //地址向后移动了一位
   	free(pTest1);
   }
   ```



**怎么避免内存泄漏？**

1、不要手动管理内存，可以尝试在适用的情况下使用智能指针。

2、使用string而不是char*。string类在内部处理所有内存管理，而且它速度快且优化得很好。

3、除非要用旧的lib接口，否则不要使用原始指针。

4、在C++中避免内存泄漏的最好方法是尽可能少地在程序级别上进行new和delete调用--最好是没有。任何需要动态内存的东西都应该隐藏在一个RAII对象中，当它超出范围时释放内存。RAII在构造函数中分配内存并在析构函数中释放内存，这样当变量离开当前范围时，内存就可以被释放。

（注：RAII资源获取即初始化，也就是说在构造函数中申请分配资源，在析构函数中释放资源）

5、使用了内存分配的函数，要记得使用其想用的函数释放掉内存。可以始终在new和delete之间编写代码，通过new关键字分配内存，通过delete关键字取消分配内存。

6、培养良好的编码习惯，在涉及内存的程序段中，检测内存是否发生泄漏。



### 5、指针和引用的区别，为什么要有指针和引用? C++推荐指针还是引用? 

1. 引用只是c++语法糖，可以看作编译器自动完成取地址、解引用的**常量指针**
2. 引用区别于指针的特性都是编译器约束完成的，一旦编译成汇编就和指针一样
3. 由于引用只是指针包装了下，所以也存在风险，比如如下代码:

```c++
int *a = new int;
int &b = *a;
delete a;
b = 12;    *// 对已经释放的内存解引用*
```

4. 引用由编译器保证初始化，使用起来较为方便(如不用检查空指针等)

5. 尽量用引用代替指针

6. 引用没有顶层const即`int & const`，因为引用本身就不可变，所以在加顶层const也没有意义； 但是可以有底层const即 `const int&`，这表示引用所引用的对象本身是常量

7. 指针既有顶层const(`int * const`--指针本身不可变)，也有底层const(`int * const`--指针所指向的对象不可变)

8. 有指针引用--是引用，绑定到指针， 但是没有引用指针--这很显然，因为很多时候指针存在的意义就是间接改变对象的值，但是引用本身的值我们上面说过了是所引用对象的地址，但是引用不能更改所引用的对象，也就当然不能有引用指针了。

9. 指针和引用的自增(++）和自减含义不同，指针是指针运算, 而引用是代表所指向的对象对象执行++或--



### 6、new和delete

用new创建动态对象时会发生两件事：

- 使用operatoe new()为对象分配内存（经常是调用malloc）
- 调用构造函数来初始化内存。

相对应的调用delete运算符

- 首先调用析构函数
- 调用operator delete()释放内存(经常是调用free)。我们无法控制构造函数和析构函数的调用，是由编译器调用的。但可以改变内存分配函数operator new()和operator delete()。



### 7、cast

**const_cast**

1、常量指针被转化成非常量的指针，并且仍然指向原来的对象； 

2、常量引用被转换成非常量的引用，并且仍然指向原来的对象； 

**static_cast**

static_cast 作用和C语言风格强制转换的效果基本一样，没有运行时类型检查来保证转换的安全性.

**dynamic_cast**

dynamic_cast是运行时处理的，运行时要进行类型检查，不能用于内置基本数据类型间的强制转换，基类中一定要有虚函数。

**reinterpret_cast**

处理无关类型之间的转换，

reinterpret_cast用在任意指针（或引用）类型之间的转换；以及指针与足够大的整数类型之间的转换；从整数类型（包括枚举类型）到指针类型，无视大小。

只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式。



### 8、智能指针

智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。

当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

C++ 11中最常用的智能指针类型为shared_ptr,它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。

对shared_ptr进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。可以通过make_shared函数或者通过构造函数传入普通指针。并可以通过get函数获得普通指针。



### 9、C++中的锁有哪些，你用过哪些 

**互斥锁（Mutex）**

​		在某一时刻，只有一个线程可以获取互斥锁，在释放互斥锁之前其他线程都不能获取该互斥锁。如果其他线程想要获取这个互斥锁，那么这个线程只能以阻塞方式进行等待。

头文件：< mutex >
类型： std::mutex

用法：在C++中，通过构造**std::mutex**的实例创建互斥元，调用成员函数lock()来锁定它，调用unlock()来解锁，不过一般不推荐这种做法，标准C++库提供了**std::lock_guard**类模板，实现了互斥元的RAII惯用语法。

```c++
//用互斥元保护列表
#include <list>
#include <mutex>

std::list<int> some_list;
std::mutex some_mutex;

void add_to_list(int new_value)
{
    std::lock_guard<std::mutex> guard(some_mutex);
    some_list.push_back(new_value);
}
```



**条件变量**

​		条件锁就是所谓的条件变量，某一个线程因为某个条件为满足时可以使用条件变量使改程序处于阻塞状态。一旦条件满足以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。最为常见就是在线程池中，起初没有任务时任务队列为空，此时线程池中的线程因为“任务队列为空”这个条件处于阻塞状态。一旦有任务进来，就会以信号量的方式唤醒一个线程来处理这个任务。

头文件：< condition_variable >

类型：std::condition_variable（只和std::mutex一起工作） 和 std::condition_variable_any（符合类似互斥元的最低标准的任何东西一起工作）。



### 10、非static的内部类如何访问static的外部成员变量或方法？原理是什么

在静态函数的形参列表加上实例的地址。

```c++
class A
{
public:
    static void test(A *a)
    {
        a->m_a += 1;
    }
    void hello()
    {
    }
private:
    static int m_staticA;
    int m_a
};
```



### 11、为什么要有move？move最根本解决什么问题？move是怎么实现的？

std::move并不能移动任何东西，它唯一的功能是将一个左值强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义。从实现上讲，std::move基本等同于一个类型转换：static_cast<T&&>(lvalue);





### 12、右值引用，那你说一下左值右值的区别，C++要有左值右值?目的是什么要解决什么问题

**在C++之中的变量只有左值与右值两种：其中凡是可以取地址的变量就是左值，而没有名字的临时变量，字面量就是右值**


C++11最重要的一个改进之一就是引入了move语义，这样在一些对象的构造时可以获取到已有的资源（如内存）而不需要通过拷贝，申请新的内存，这样移动而非拷贝将会大幅度提升性能。例如有些右值即将消亡析构，这个时候我们用移动构造函数可以接管他们的资源。



### 13、设计一下shared_ptr

```c++
template <typename T>
class shared_ptr 
{
    public:
        shared_ptr(T* p) : count(new int(1)), _ptr(p) {}
    	shared_ptr(shared_ptr<T>& other) : count(&(++*other.count)), _ptr(other._ptr) {}
        shared_ptr<T>& operator=(const shared_ptr<T>& other)
        {
            ++*other.count;
            if (this->_ptr && 0 == --*this->count)
            {
                delete count;
                delete _ptr;
            }
            this->_ptr = other._ptr;
            this->count = other.count;
            return *this;
        }
        ~shared_ptr()
        {
            if (--*count == 0)
            {
                delete count;
                delete _ptr;
            }
        }
    
        T* operator->() { return _ptr; }
        T& operator*() { return *_ptr; }
    
        int getRef() { return *count; }
    
    private:
        int* count;
        T* _ptr;
};
```



### 14、多态说一下?虚表? 

C++中虚函数是通过一张虚函数表(Virtual Table)来实现的，在这个表中，主要是一个类的虚函数表的地址表；这张表解决了继承、覆盖的问题。在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以当我们用父类的指针来操作一个子类的时候，这张虚函数表就像一张地图一样指明了实际所应该调用的函数。

**C++编译器是保证虚函数表的指针存在于对象实例中最前面的位置**(是为了保证取到虚函数表的最高的性能)，这样我们就能通过已经实例化的对象的地址得到这张虚函数表，再遍历其中的函数指针，并调用相应的函数。



### 15、野指针，内存泄漏，栈溢出都是些什么?

**野指针**

1. 指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。

```
char *p; //此时p为野指针
```

2. 指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针.

```
char *p=new char[10];  //指向堆中分配的内存首地址，p存储在栈区
cin>> p;
delete []p; //p重新变为野指针
```

3. 指针操作超越了变量的作用范围。     

```
char *p=new char[10]; //指向堆中分配的内存首地址
cin>> p;
cout<<*(p+10); //可能输出未知数据
```



**栈溢出**

栈溢出就是缓冲区溢出的一种。 由于缓冲区溢出而使得有用的存储单元被改写, 往往会引发不可预料的后果。程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区。如果向缓冲区中写入超过其本身长度的数据，以致于缓冲区无法容纳，就会造成缓冲区以外的存储单元被改写，这种现象就称为缓冲区溢出。缓冲区长度一般与用户自己定义的缓冲变量的类型有关。

- 减少栈空间的需求，不要定义占用内存较多的auto变量，应该将此类变量修改成指针，`从堆空间分配内存`。
- 函数参数中不要传递大型结构/联合/对象，应该使用`引用或指针作为函数参数`。
- 减少函数调用层次，`慎用递归函数`，例如A->B->C->A环式调用。



### 16、const修饰的函数作用是什么

int get() const;

1. 常量成员函数不修改对象

2. 常量成员函数在定义和声明中都应加const限定

3. 非常量成员函数不能被常量成员函数调用，但构造函数和析构函数除外

4. 常量（const对象）对象只能调用常量成员函数



### 17、移动语义

移动语义意味着两点：

- **原对象不再被使用**，如果对其使用会造成不可预知的后果。
- 所有权转移，资源的所有权被转移给新的对象。

移动语义通过**移动构造函数**和**移动赋值操作符**实现，其与拷贝构造函数类似，区别如下：

- 参数的符号必须为右值引用符号，即为&&。
- 参数不可以是常量，因为函数内需要修改参数的值
- 参数的成员转移后需要修改（如改为nullptr），避免临时对象的析构函数将资源释放掉。



### 18、完美转发，什么场景使用

```cpp
template <typename T>
T&& forward(typename std::remove_reference<T>::type& param)
{
    return static_cast<T&&>(param);
}

template <typename T>
T&& forward(typename std::remove_reference<T>::type&& param)
{
    return static_cast<T&&>(param);
}
```

第一个是左值引用模板函数，第二个是右值引用模板函数。

紧接着std::forward模板函数对传入的参数进行强制类型转换，转换的目标类型符合引用折叠规则，因此左值参数最终转换后仍为左值，右值参数最终转成右值。



### 19、友元函数

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。



为什么会有友元函数？

结合着类的特性和类中一般成员函数，我们可以这样理解：类具有封装和信息隐藏的特性。只有类的成员函数才能访问类的私有成员，程序中的其他函数是无法访问私有成员的。非成员函数可以访问类中的公有成员，但是如果将数据成员都定义为公有的，这又破坏了隐藏的特性。另外，应该看到在某些情况下，特别是在对某些成员函数多次调用时，由于参数传递，类型检查和安全性检查等都需要时间开销，而影响程序的运行效率。

为了解决上述问题，提出一种使用友元的方案。友元是一种定义在类外部的普通函数，但它需要在类体内进行说明，为了与该类的成员函数加以区别，在说明时前面加以关键字friend。友元不是成员函数，但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率，但是，它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。

友元函数的特点是能够访问类中的私有成员的非成员函数。友元函数从语法上看，它与普通函数一样，即在定义上和调用上与普通函数一样。



### 20、访问控制符

**public、protected和private**

1. public成员：能被本类的成员函数（不管是哪一种控制符声明的成员函数，都可以）、友元函数、本类的对象、其派生类的成员函数（不管是哪一种控制符声明的成员函数，都可以）；

2. protected成员：能被本类的成员函数（不管是哪一种控制符声明的成员函数，都可以）、友元函数、其派生类的成员函数（不管是哪一种控制符声明的成员函数，都可以）；

3. private成员：能被本类的成员函数（不管是哪一种控制符声明的成员函数，都可以）、友元函数；



### 21、NULL和nullptr的区别

NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议以后还是都用nullptr替代NULL吧，而NULL就当做0使用。



### 22、shared_ptr里引用计数器是怎么实现共享的？

引用计数法的内部实现:

1. 这个引用计数器保存在某个内部类型中，而这个内部类型对象在shared_ptr第一次构造时以指针的形式保存在shared_ptr中

2. shared_ptr重载了赋值运算符，在赋值和拷贝另一个shared_ptr时，这个指针被另一个shared_ptr共享

3. 在引用计数归0时，这个内部类型指针与shared_ptr管理的资源一起释放

4. 此外，为了保证线程安全，引用计数器的加1和减1都是原子操作，它保证了shared_ptr由多个线程共享时不会爆掉



### 23、shared_ptr是线程安全的吗？

多线程读写shared_ptr需要加锁。



### 24、atomic

std::atomic 是模板类，一个模板类型为 T 的原子对象中封装了一个类型为 T 的值。

```
template <class T> struct atomic;
```

原子类型对象的主要特点就是从不同线程访问不会导致数据竞争(data race)。因此从不同线程访问某个原子对象是良性 (*well-defined*) 行为，而通常对于非原子类型而言，并发访问某个对象（如果不做任何同步操作）会导致未定义 (*undifined*) 行为发生。



### 25、static是线程安全的吗？

C++11中，static静态类对象在执行构造函数进行初始化的过程是线程安全的。



### 26、让你实现malloc和free的内存分配和释放，你怎么设计，考虑内存碎片问题？

会有内部碎片与外部碎片的问题，内部碎片难以消除（因为字对齐之类的问题），而外部碎片是可以消除的（如果不消除的话，外部的内存块越来越小，虽然数量多了，但是利用率会急剧下降！）

**内存池原理**

内存池的思想是，在真正使用内存之前，**预先申请分配**一定数量、大小预设的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够再继续申请新的内存，当内存释放后就回归到内存块留作后续的复用，使得内存使用效率得到提升，一般也不会产生不可控制的内存碎片。

**内存池设计**

算法原理：

1. 预申请一个内存区chunk，将内存中按照对象大小划分成多个内存块block
2. 维持一个空闲内存块链表，通过指针相连，标记头指针为第一个空闲块
3. 每次新申请一个对象的空间，则将该内存块从空闲链表中去除，更新空闲链表头指针
4. 每次释放一个对象的空间，则重新将该内存块加到空闲链表头
5. 如果一个内存区占满了，则新开辟一个内存区，维持一个内存区的链表，同指针相连，头指针指向最新的内存区，新的内存块从该区内重新划分和申请



### 27、外碎片如何处理？

- 分配内存和释放的内存尽量在同一个函数中（避免内存泄漏）
- 尽量一次性申请较大的内存2的指数次幂大小的内存空间，而不要反复申请小内存(少进行内存的分割)
- 做内存池，也就是自己一次申请一块足够大的空间，然后自己来管理，用于大量频繁地new/delete操作。



### 28、为什么要重载operator new和operator delete

由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。

当你必须要使用new和delete的时候，你不得不控制C++中的内存分配。你需要用重载的全局new和delete代替系统的内存分配符。需要给类重载new和delete。

一个防止内存破碎的方法是从不同固定大小的内存池中分配不同类型的对象。对单个类重载new和delete，你就可以灵活的控制内存分配。



### 29、int a[10]; 该数组的变量和内容都存在哪里？

栈上



### 30、指针数组和数组指针

指针数组：首先它是一个数组，数组的元素都是指针，数组占多少个字节由数组本身决定。它是“储存指针的数组”的简称。

数组指针：首先它是一个指针，它指向一个数组。在32 位系统下永远是占4 个字节，至于它指向的数组占多少字节，不知道。它是“指向数组的指针”的简称。

```c++
int *p1[10]; // 指针数组

int (*p2)[10]; // 数组指针
```



### 31、结构体对齐

**对齐原则：**

1. 原则1：数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照`#pragma pack`指定的数值和这个数据成员自身长度中，比较小的那个进行。
2. 原则2：结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。
3. 原则3：结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。



### 32、编译过程

编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件。

读取源程序，对之进行词法和语法分析，将高级语言指令转换为功能等效的汇编代码，源文件的编译过程包含两个过程：

**预编译**

读取源程序，对其中的伪指令（以#开头的指令）和特殊符号进行处理。

宏定义指令

条件编译指令

头文件包含指令

特殊符号

**编译、优化阶段**

经过预编译得到的输出文件中，只有常量；如数字、字符串、变量的定义，以及C语言的关键字，如main, if , else , for , while , { , } , + , - , * , \ 等等。

编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。

------

汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件。

------

链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件。



### 33、虚函数表和虚函数指针存放在那个位置

1. 虚函数表是全局共享的元素，即全局仅有一个

2. 虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表。即虚函数表不是函数，不是程序代码，不肯能存储在代码段

3. 虚函数表存储虚函数的地址，即虚函数表的元素是指向类成员函数的指针，而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定，即大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

