### 1、C++ vector是如何实现扩容的？



### 2、priority_queue底层是怎么实现的？（堆）

```c++
//升序队列 
priority_queue <int,vector<int>,greater<int> > q; //小顶堆
//降序队列 
priority_queue <int,vector<int>,less<int> >q; //大顶堆
```

#include<queue> 和queue不同的地方在于能自定义数据的优先级，默认是大顶堆。



### 3、priority_queue插入一个元素，底层怎么做的？



### 4、Vector和List的区别

数组插入和删除操作的时间复杂度是O(n)。而数组是有序的，可以直接通过下标访问元素，十分高效，访问时间复杂度是O(1)（常数时间复杂度）。

**如果某些场景需要频繁插入和删除元素时，这时候不宜选用数组作为数据结构**。

频繁访问的场景下，可以使用数组。

反之，**频繁插入或删除的场景用链表**



### 5、队列和栈的区别和用途



### 6、哈希表，哈希冲突怎么解决

1. **开放地址方法**

   一旦发生了冲突，就去寻找下一个空的散列地址。

   线性探测

   按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上往后加一个单位，直至不发生哈希冲突。　

   再平方探测

   按顺序决定值时，如果某数据的值已经存在，则在原来值的基础上先加1的平方个单位，若仍然存在则减1的平方个单位。随之是2的平方，3的平方等等。直至不发生哈希冲突。

   伪随机探测

   按顺序决定值时，如果某数据已经存在，通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。

2. **链式地址法（HashMap的哈希冲突解决方法）**

　    对于相同的值，使用链表进行连接，使用数组存储每一个链表。

3. **建立公共溢出区**

　　这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表

4. **再哈希法**

   再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。

