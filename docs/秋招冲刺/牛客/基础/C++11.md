## C++11有哪些新特性？

C++11 最常用的新特性如下：

auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导

nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。

智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。

初始化列表：使用初始化列表来对类进行初始化

右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率

atomic原子操作用于多线程资源互斥操作

新增STL容器array以及tuple



#### 可变参数模板

```c++
Template<class ... T>
void func(T ... args)
{
cout<<”num is”<<sizeof ...(args)<<endl;
}

//使用
func(); //不含参数
func(1); //包含一个int类型
func(1, 2.0); //包含一个int和一个double
```



#### 右值引用

C++中，左值通常可以取地址，有名字的值就是左值，而不能取地址、没有名字的就是右值，

而在C++11中，右值是由两个概念构成，**将亡值**和**纯右值**。

- 纯右值是用于识别临时变量和一些不跟对象关联的值，比如1+3产生的临时变量值，2、true等
- 将亡值通常是指具有转移语义的对象，比如返回右值引用T&&的函数返回值等

C++11中，右值引用就是对一个右值进行引用的类型。由于右值通常不具有名字，所以我们一般只能通过右值表达式获得其引用，比如：

**T && a=ReturnRvale();**

假设ReturnRvalue()函数返回一个右值，那么上述语句声明了一个名为a的右值引用，其值等于ReturnRvalue函数返回的临时变量的值。



#### 引用折叠

在调用函数f的时候，我们可能传入一个左值，也可能传入一个右值。

由于存在T&&这种未定的引用类型，当它作为参数时，有可能被一个左值引用或者右值引用的参数初始化，这时候经过类型推导的T&&类型相比右值引用会发生变化。

- 所有右值引用折叠到右值引用上仍然是一个右值引用。（A&& && 变成 A&&）
- 所有的其他引用类型之间的折叠都将变成左值引用。 （A& & 变成 A&; A& && 变成 A&; A&& & 变成 A&）



#### 移动语义

在对象的构造时可以获取到已有的资源，而不用通过拷贝申请新的内存，这样移动而非拷贝可以大幅提高性能。例如有些右值即将消亡析构，这时候我们用移动构造可以接管它们的资源。



#### 完美转发

完美转发是指在函数模板中，完全依照模板的参数的类型，将参数传递给函数模板中调用的另一个函数，即传入转发函数的是左值对象，目标函数就能获得左值对象，转发函数是右值对象，目标函数就能获得右值对象，而不产生额外的开销。

因此转发函数和目标函数参数一般采用引用类型，从而避免拷贝的开销。其次，由于目标函数可能需要能够既接受左值引用，又接受右值引用，所以考虑转发也需要兼容这两种类型。
