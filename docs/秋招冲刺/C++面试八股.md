https://mp.weixin.qq.com/s/qhFERQ1odNkgZS0PkHm1EA

### C++基础

1. C语言和C++有什么区别？

   面向对象语言，继承派生，多态，虚函数

   模板

   STL

2. struct和class的区别？

   struct能包含成员函数吗？ 能

   struct能继承吗？ 能

   struct能实现多态吗？ 能

   既然这些它都能实现，那它和class还能有什么区别？

   最本质的一个区别就是默认的访问控制：

   默认的继承访问权限

   struct是public的，class是private的。

3. 函数重载和覆盖有什么区别？

   ① 重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。

   ② 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。

4. 面向对象、面向过程？

5. 什么场景下使用继承，什么场景下使用组合？

   "is a" 和 “has a”

6. 对多态的理解，运行时多态的实现原理是什么？]

   虚函数

7. 对虚函数机制的理解，单继承、多继承、虚继承下虚表的结构

8. 什么场景下要用到纯虚函数？基类的构造函数可以调用虚函数吗？

   一：

   ​		一般情况下，纯虚函数是用来定义抽象基类的时候来使用的。所谓的抽象基类就是一种不用来定义对象，而只作为一种基本类型用作继承的抽象类，而常常用它来作为基类，所以叫抽象基类。凡是包含纯虚函数的类都是抽象类。因为纯虚函数时不能被调用

   的，包含纯虚函数的类是无法建立对象的。抽象类的作用是作为一个类族的共同基类，或者为一个类族提供一个公共接口。

   ​		在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象

   明显不合常理，动物只是一个抽象概念，动物都有动作、大小等属性，但只有具体到某一类动物的时候这些属性才能具体化，所

   以动物只能实现为接口，即抽象类，把动作等属性定义为纯虚函数C++通过使用纯虚函数提供未实现的函数。一般情况下，纯虚

   函数是用来定义抽象基类的时候来使用的。这样，纯虚函数会在子类中被重载，这样可以实现用相同的接口去做不同的事。

   二：

   ​		**永远不要在构造函数或析构函数中调用虚函数** 。

9. 构造函数可以是虚函数吗？析构函数呢？

   ​		虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数——构造函数了。

   ​		首先析构函数可以为虚函数，而且当要使用基类指针或引用调用子类时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。

   举例说明：

   子类B继承自基类A；**A \*p = new B; delete p;**

   1） 此时，如果类A的析构函数不是虚函数，那么delete p；**将会仅仅调用A的析构函数，只释放了B对象中的A部分，而派生出的新的部分未释放掉。**

   2） 如果类A的析构函数是虚函数，delete p; 将会先调用B的析构函数，再调用A的析构函数，释放B对象的所有空间。

   补充： B *p = new B; delete p;时也是先调用B的析构函数，再调用A的析构函数。

10. 指针和引用的区别？什么情况下用指针，什么情况用引用？

    一：

    引用必须初始化，不存在指向空值的引用。

    指针可以被重新赋值以指向另一个不同的对象，引用总是指向在初始化时被指定的对象，以后不能改变。

    二：

    在以下情况应该使用指针，**一是考虑到存在不指向任何对象的可能**，**二是需要在不同的时刻指向不同的对象**

    **如果总是指向一个对象并且一旦指向一个对象后就不会改变指向**，那么应该使用引用。

    还有一种情况，当重载某个操作符时，你应该使用引用。最普通的例子是操作符 [ ]，这个操作符返回一个对象，且能被赋值。

11. 如何实现一个线程池？

12. 各种强制类型转换

13. extern C

    extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。

    在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？
    C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。

14. RAII

     [RAII.md](..\C++\RAII.md) 

15. new和malloc有什么区别？

    malloc/free是函数，new/delete是cpp运算符

    new/delete比malloc/free更加智能，其实底层也是执行的malloc/free。为啥说new/delete更加的智能？因为new和delete在对象创建的时候自动执行构造函数，对象消亡之前会自动执行析构函数。

    new返回指定类型的指针，并且可以自动计算出所需要的大小。如 ：

    ```c++
    int *p;    p = new int;      //返回类型为int*类型，大小为sizeof(int);
    
    int *pa; pa = new int[50];   //返回类型为int *，大小为sizeof(int) * 100;
    ```

    malloc必须用户指定大小，并且默然返回类型为void*,必须强行转换为实际类型的指针。

16. malloc的内存可以用delete释放吗？new出来的内存用free呢？

17. 类的大小怎么计算？空类的大小是多少？

    空类型不包含任何信息，按理来说它的sizeof应该是0。但是，要考虑的是当我们声明该类型的实例的时候，它**必须在内存中占有一定的空间**，否则它就是不存在的而无法使用这些实例。因此，具体在内存中占用的空间大小是多少由编译器确定，在vs中一个空类型的实例占用1字节的空间。

18. volatile关键字

    volatile关键字和const关键字相对应，const关键字告诉编译器其修饰的变量是只读的，编译器根据只读属性做一些操作，而volatile关键字告诉编译器其修饰的变量是易变的，同理编译器根据易变属性也会做一些操作。它会确保修饰的变量每次都读操作都从内存里读取，每次写操作都将值写到内存里。volatile关键字就是给编译器做个提示，告诉编译器不要对修饰的变量做过度的优化，提示编译器该变量的值可能会以其它形式被改变。

19. malloc出来100字节内存，为什么free不用传入具体长度呢？

20. new[]和delete[]一定要配对使用吗？

    因为new[]会创建一个数组，一个对象数组需要一定的空间大小，假设一个对象需要N字节大小，K个对象的数组就需要K*N个空间来构造对象数组，但是在delete[]时候，如何知道数组的长度呢？

    所以new[]会在K * N个空间的基础上，头部多申请4个字节，用于存储数组长度，这样delete[]时候才知道对象数组的大小，才会相应调用K次析构函数，并且释放K*N+4大小的内存。

    - 当类型为int, float等内置类型时，new、delete、new[]、delete[]不需要配对使用；

    - 当是自定义类型时，new、delete和new[]、delete[]才需要配对使用。



#### C++新特性

智能指针

auto、decltype

左值引用、右值引用

移动语义和完美转发

enum和enum class有什么区别

function、bind、lambda使用场景

share_ptr和unique_ptr有什么区别

unique_ptr如何转移所有权

mutex、RAII lock

一般什么情况下会出现内存泄漏？出现内存泄漏怎么调试



### STL

使用过的标准库

list的使用场景

string的常用函数

deque的底层数据结构是什么？

map和unordered_map有什么区别？使用场景

C++直接使用数组好还是array好？array是怎么实现的？

vector的最大特点？内部实现？resize和reserve的区别是什么？clear实现？

push_back/emplace_back



### 设计模式

如果你能知道所有的设计模式最好，即便不知道所有的设计模式，下面这些高频设计模式你还是需要了解的。

1. 分别写出饿汉和懒汉线程安全的单例模式
2. 说出观察者模式类关系和优点
3. 说出代理模式类关系和优点
4. 说出工厂模式概念和优点
5. 说出构造者模式概念
6. 说出适配器模式概念



### 操作系统

1. 进程和线程的区别？[深度好文|面试官：进程和线程，我只问这19个问题](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484716&idx=1&sn=d9eb61162dab2c6da9b9f153fe4319b4&chksm=c21d3790f56abe8682f52b11ed9a65c7138a4942f34336d3745355d44fffd535eadb13d2b9a4&scene=21#wechat_redirect)

2. 操作系统是怎么进行进程管理的？

   进程控制块(PCB)（系统为了管理进程设置的一个专门的数据结构，用它来记录进程的外部特征，描述进程的运动变化过程。系统利用PCB来控制和管理进程，所以PCB是系统感知进程存在的唯一标志。进程与PCB是一一对应的）

3. 操作系统是如何做到进程阻塞的？

4. 进程之间的通信方式有哪些？

    [进程间通信方式.md](..\操作系统\进程线程\进程间通信方式.md) 

5. 什么是上下文切换，操作系统是怎么做的上下文切换？

6. 线程是如何实现的？

7. 线程之间私有和共享的资源有哪些？

8. 一般应用程序内存空间的堆和栈的区别是什么？

9. 进程虚拟空间是怎么布局的？[10张图22段代码，万字长文带你搞懂虚拟内存模型和malloc内部原理](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484726&idx=1&sn=18d9dc7f8b76a2a9a0b29b39ff6dabea&chksm=c21d378af56abe9c56f3d4da55b4d2d90995bae0e1a4a13c3e5cf7f33473d2642615b445aeb1&scene=21#wechat_redirect)

10. 虚拟内存是如何映射到物理内存的？了解分页内存管理吗？[操作系统内存管理，你能回答这8个问题吗？](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484706&idx=1&sn=f99afd2c8c38d97d0e4d333f9c821143&chksm=c21d379ef56abe881bc15e963ea0a8417fb2e80ca022d86024be1d9dbe6e6009396520031e0d&scene=21#wechat_redirect)

11. 产生死锁的必要条件有哪些？如何避免死锁？

12. 什么是大端字节，什么是小端字节？如何转换字节序？

13. 信号和信号量的区别是什么？

14. 锁的性能开销，锁的实现原理？

15. 了解CPU的Cache吗？如何写一个高效的多维矩阵乘法？[如何利用CPU Cache写出高性能代码，看这些图就够了！](http://mp.weixin.qq.com/s?__biz=MzkyODE5NjU2Mw==&mid=2247484740&idx=1&sn=d8fc981374061ed8d75b9e29cd6d16da&chksm=c21d37f8f56abeee9cc7594ab57bc3694984f00a363ad4cbbd5f0ecc5554628e793eed25a120&scene=21#wechat_redirect)

