## 76. 最小覆盖字串

![fig1](https://assets.leetcode-cn.com/solution-static/76/76_fig1.gif)

​		我们可以用滑动窗口的思想解决这个问题。在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 rr 指针，和一个用于「收缩」窗口的 ll 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 ss 上滑动窗口，通过移动 rr 指针不断扩张窗口。当窗口包含 tt 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。



```c++
class Solution 
{
public:
    string minWindow(string s, string t) 
    {
        vector<int> chars(128, 0);
        vector<bool> flag(128, false);

        //记录t种字符的情况
        for(int i = 0; i < t.size(); ++i)
        {
            flag[t[i]] = true;
            ++chars[t[i]];
        }

        int cnt = 0, left = 0, min_l = 0, min_size = s.size()+1;
        for(int r = 0; r< s.size(); ++r)
        {
            if(flag[s[r]])
            {
                if(--chars[s[r]] >=0)
                ++cnt;
            }

            //若滑动窗口已经包含全部t中字符
            //尝试将l右移，在不影响结果的情况获得最短字符串
            while(cnt == t.size())
            {
                if(r-left+1 < min_size)
                {
                    min_l = left;
                    min_size = r-left+1;
                }
                if(flag[s[left]] && ++chars[s[left]] > 0)
                {
                    --cnt;
                }
                ++left;
            }
        }
        return min_size > s.size() ? string() : s.substr(min_l, min_size);
    }
};
```

